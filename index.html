<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bloopr</title>
    <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Ctext y='0.9em' x='0.1em' font-size='90'%3E%F0%9F%8E%B2%3C/text%3E%3C/svg%3E" />
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            background: transparent;
            cursor: pointer;
        }
        input[type="range"]::-webkit-slider-track {
            height: 4px;
            border-radius: 2px;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: rgb(168, 85, 247);
            cursor: pointer;
            margin-top: -6px;
        }
        input[type="range"]::-moz-range-track {
            height: 4px;
            border-radius: 2px;
        }
        input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: rgb(168, 85, 247);
            cursor: pointer;
            border: none;
        }
        
	.time-display {
    	    font-size: 0.75rem;
    	    color: rgb(148, 163, 184);
	}

        .highlight-pulse { animation: highlightPulse 2s ease-out 1; border-color: rgb(236,72,153) !important; }
        .highlight-pulse-5 { animation: highlightPulse 5s ease-out 1; border-color: rgb(236,72,153) !important; }
        @keyframes highlightPulse {
            0% { box-shadow: 0 0 0 0 rgba(236,72,153,0.95); }
            50% { box-shadow: 0 0 0 12px rgba(236,72,153,0.0); }
            100% { box-shadow: 0 0 0 0 rgba(236,72,153,0.0); }
	}
    </style>
<style>
.scroll-area { -webkit-overflow-scrolling: touch; scroll-behavior: smooth; }

/* Dice Rolling Animation */
.dice-rolling {
    animation: diceRoll 1s ease-in-out;
}

@keyframes diceRoll {
    0% { transform: rotateX(0deg) rotateY(0deg) rotateZ(0deg) scale(0.8); opacity: 0.5; }
    25% { transform: rotateX(180deg) rotateY(90deg) rotateZ(45deg) scale(1.1); opacity: 0.8; }
    50% { transform: rotateX(360deg) rotateY(180deg) rotateZ(90deg) scale(0.9); opacity: 0.9; }
    75% { transform: rotateX(540deg) rotateY(270deg) rotateZ(135deg) scale(1.05); opacity: 1; }
    100% { transform: rotateX(720deg) rotateY(360deg) rotateZ(180deg) scale(1); opacity: 1; }
}

/* Coin Flipping Animation */
.coin-flipping {
    animation: coinFlip 0.8s ease-in-out;
}

@keyframes coinFlip {
    0% { transform: rotateY(0deg) scale(0.8); }
    25% { transform: rotateY(90deg) scale(1.1); opacity: 0.7; }
    50% { transform: rotateY(180deg) scale(1); opacity: 0.5; }
    75% { transform: rotateY(270deg) scale(1.1); opacity: 0.7; }
    100% { transform: rotateY(360deg) scale(1); opacity: 1; }
}

.dice-face {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: 80px;
    height: 80px;
    background: linear-gradient(135deg, #1e293b, #334155);
    border: 3px solid #64748b;
    border-radius: 12px;
    font-size: 2rem;
    font-weight: bold;
    color: #f1f5f9;
    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    position: relative;
}

.dice-face::before {
    content: '';
    position: absolute;
    inset: 4px;
    border-radius: 8px;
    background: linear-gradient(135deg, rgba(255,255,255,0.1), rgba(255,255,255,0.05));
}

.coin-face {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: 100px;
    height: 100px;
    border-radius: 50%;
    font-size: 1.5rem;
    font-weight: bold;
    color: #f1f5f9;
    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    position: relative;
    border: 4px solid #fbbf24;
}

.coin-heads {
    background: linear-gradient(135deg, #fbbf24, #f59e0b);
}

.coin-tails {
    background: linear-gradient(135deg, #eab308, #ca8a04);
}

.dice-container {
    perspective: 1000px;
}
</style>
<style>
/* Light mode overrides */
body.light-mode {
    background-image: none !important;
    background-color: #f8fafc !important; /* slate-50 */
    color: #0f172a !important; /* slate-900 */
}
.light-mode [class*="text-white"] { color: #0f172a !important; }
.light-mode [class*="bg-slate-900"],
.light-mode [class*="bg-slate-800"],
.light-mode [class*="bg-slate-700"] { background-color: #f1f5f9 !important; } /* slate-100 */
.light-mode [class*="border-slate-700"],
.light-mode [class*="border-purple-500"] { border-color: #cbd5e1 !important; } /* slate-300 */
.light-mode [class*="text-slate-300"] { color: #334155 !important; } /* slate-700 */
.light-mode [class*="text-slate-400"] { color: #475569 !important; } /* slate-600 */
.light-mode [class*="bg-slate-700 hover:bg-slate-600"] { background-color: #e2e8f0 !important; }
.light-mode #active-sounds-bar { background-color: rgba(248,250,252,0.95) !important; }
    </style>
</head>
<body class="min-h-screen bg-gradient-to-br from-slate-900 via-purple-900 to-slate-900 text-white relative">
    <!-- Corner Ribbon -->
    <a id="buy-me-coffee-ribbon" href="#" target="_blank" rel="noopener noreferrer" class="absolute top-0 left-0 z-40 block overflow-hidden w-32 h-32">
        <div class="absolute -left-8 top-8 w-40 bg-gradient-to-r from-amber-500 to-amber-600 text-white text-[11px] font-semibold py-1.5 px-2 shadow-xl" style="transform: rotate(-45deg);">
            <div class="flex items-center gap-1 justify-center">
                <span>â˜•</span>
                <span>Buy me a coffee</span>
            </div>
        </div>
    </a>
    <div class="container mx-auto px-4 py-8 pb-32">
        <div class="relative mb-4">
            <div class="absolute right-0 top-0 flex items-center gap-2 z-10">
                <button onclick="toggleLightMode()" class="px-3 py-2 rounded-full bg-slate-800 border border-slate-700 hover:bg-slate-700 text-slate-200 text-sm md:text-base" aria-label="Toggle light mode">ğŸŒ“</button>
                <button onclick="openInfoModal()" class="px-3 py-2 rounded-full bg-slate-800 border border-slate-700 hover:bg-slate-700 text-slate-200 text-sm md:text-base" aria-label="Info and Help">â„¹ï¸</button>
            </div>
            <div class="text-center pl-20 pr-20 mx-auto max-w-full">
                <h1 class="text-3xl md:text-4xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-purple-400 to-pink-400">Bloopr</h1>
                <div id="active-session-label" class="mt-1 text-slate-300 text-sm break-words px-2">Game Session: Default</div>
            </div>
        </div>

        <!-- Search Section -->
        <div class="mb-4">
            <input id="quick-search-input" type="text" placeholder="Quick search..." oninput="performQuickSearch(this.value)" onblur="clearQuickSearchIfEmpty()" class="w-full px-4 py-3 bg-slate-800 border border-slate-700 rounded-lg focus:outline-none focus:ring-2 focus:ring-purple-500 text-base" />
        </div>

        <!-- Quick Actions: Dice, Coin, Scenes -->
        <div class="mb-4 flex gap-2">
            <button onclick="rollRandomDice()" class="flex-1 flex items-center justify-center gap-2 px-4 py-3 rounded-lg text-sm md:text-base transition-all shadow-sm active:scale-[0.98] bg-gradient-to-r from-yellow-600 to-orange-600 hover:from-yellow-500 hover:to-orange-500">
                <span class="text-xl">ğŸ²</span>
                <span class="font-medium">Dice</span>
            </button>
            <button onclick="flipCoinInline()" class="flex-1 flex items-center justify-center gap-2 px-4 py-3 rounded-lg text-sm md:text-base transition-all shadow-sm active:scale-[0.98] bg-gradient-to-r from-amber-600 to-yellow-600 hover:from-amber-500 hover:to-yellow-500">
                <span class="text-xl">ğŸª™</span>
                <span class="font-medium">Coin</span>
            </button>
            <button onclick="openGroupsModal()" class="flex-1 flex items-center justify-center gap-2 px-4 py-3 rounded-lg text-sm md:text-base transition-all shadow-sm active:scale-[0.98] bg-gradient-to-r from-orange-600 to-red-600 hover:from-orange-500 hover:to-red-500">
                <span class="text-xl">ğŸµ</span>
                <span class="font-medium">Scenes</span>
            </button>
        </div>

        <!-- Favorites Section -->
        <div id="favorites-section" class="mb-4">
            <div class="mb-3">
    <h2 class="text-xl font-semibold flex items-center gap-2">
        <svg class="w-5 h-5 fill-yellow-400 text-yellow-400" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"></polygon></svg>
                    Favourites
    </h2>
            </div>
            <div class="flex flex-wrap gap-2 p-2 bg-slate-800/40 border border-slate-700 rounded-xl mb-3">
                <button onclick="openSessionsModal()" class="px-3 py-2 rounded bg-slate-700 hover:bg-slate-600 text-sm">Game Sessions</button>
                <button onclick="exportFavorites()" class="px-3 py-2 rounded bg-indigo-600 hover:bg-indigo-700 text-sm">Export</button>
                <button onclick="openImportModal()" class="px-3 py-2 rounded bg-purple-600 hover:bg-purple-700 text-sm">Import</button>
                <button onclick="clearAllFavorites()" class="px-3 py-2 rounded bg-rose-600 hover:bg-rose-700 text-sm flex items-center gap-1">
                    <svg class="w-4 h-4" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg>
                    <span>Clear</span>
                </button>
                <button onclick="openPresetModal()" class="px-3 py-2 rounded bg-emerald-600 hover:bg-emerald-700 text-sm flex items-center gap-1">
                    <span>ğŸ›ï¸</span>
                    <span>Presets</span>
                </button>
            </div>
            <div id="favorites-grid" class="grid grid-cols-5 sm:grid-cols-6 md:grid-cols-6 lg:grid-cols-8 xl:grid-cols-10 2xl:grid-cols-12 gap-2"></div>
        </div>

<!-- Expandable Categories -->
<div class="mb-4 flex gap-2">
    <button onclick="expandAll()" class="flex-1 px-4 py-4 bg-slate-800/30 backdrop-blur rounded-lg border border-slate-700 hover:bg-slate-700/50 transition-colors flex items-center justify-center gap-3">
        <span class="text-2xl">â¬‡ï¸</span>
        <span class="font-semibold text-lg">Expand All</span>
    </button>
    <button onclick="collapseAll()" class="flex-1 px-4 py-4 bg-slate-800/30 backdrop-blur rounded-lg border border-slate-700 hover:bg-slate-700/50 transition-colors flex items-center justify-center gap-3">
        <span class="text-2xl">â¬†ï¸</span>
        <span class="font-semibold text-lg">Collapse All</span>
    </button>
</div>
<div id="categories-container"></div>

        <!-- Sound Grid removed: categories now handle listing -->
        
        <!-- Footer -->
        <div class="mt-8 pt-6 pb-4 text-center text-xs text-slate-400 border-t border-slate-700/50">
            <div class="flex items-center justify-center gap-3 flex-wrap">
                <span>Created by Liam Double</span>
                <span class="text-slate-600">â€¢</span>
                <a id="buy-me-coffee-footer" href="#" target="_blank" rel="noopener noreferrer" class="text-slate-300 hover:text-amber-400 transition-colors inline-flex items-center gap-1">
                    â˜• Buy me a coffee
                </a>
            </div>
        </div>
    </div>

    <!-- Active Sounds Bar -->
    <div id="active-sounds-bar" class="hidden fixed bottom-0 left-0 right-0 bg-slate-900/95 backdrop-blur border-t border-purple-500/30 p-4 shadow-lg">
        <h3 class="text-lg font-semibold mb-3 flex items-center gap-2 justify-between">
            <span class="inline-flex items-center gap-2">
            <svg class="w-5 h-5" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"></path></svg>
            Active Sounds (<span id="active-count">0</span>)
            </span>
            <div class="flex items-center gap-2">
                <button onclick="toggleActiveBarSize()" class="px-2 py-1 bg-slate-700 hover:bg-slate-600 rounded text-xs transition-colors min-w-[4rem]" id="activebar-size-btn">Expand</button>
                <button onclick="clearAllActiveSounds()" class="px-3 py-1 bg-red-600 hover:bg-red-700 rounded text-sm transition-colors">Clear All</button>
            </div>
        </h3>
        <div id="active-sounds-grid" class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-3 max-h-48 overflow-y-auto scroll-area"></div>
    </div>

    <!-- Preset Modal -->
    <div id="preset-modal" class="hidden fixed inset-0 z-50">
        <div class="absolute inset-0 bg-slate-900/70 backdrop-blur-sm" onclick="closePresetModal()"></div>
        <div class="relative mx-auto mt-16 w-11/12 max-w-4xl bg-slate-900 border border-slate-700 rounded-lg shadow-2xl max-h-[80vh] flex flex-col">
            <div class="flex items-center justify-between p-4 border-b border-slate-700 flex-shrink-0">
                <h3 class="text-lg font-semibold">Choose a Preset</h3>
                <button onclick="closePresetModal()" class="px-3 py-1 bg-slate-700 hover:bg-slate-600 rounded">Close</button>
            </div>
            <div class="p-4 border-b border-slate-700 flex-shrink-0">
                <input id="preset-search-input" type="text" placeholder="Search presets..." oninput="performPresetSearch(this.value)" class="w-full px-3 py-2 bg-slate-800 border border-slate-700 rounded focus:outline-none focus:ring-2 focus:ring-purple-500" />
            </div>
            <div id="preset-grid" class="p-4 grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4 overflow-y-auto flex-1 scroll-area"></div>
        </div>
    </div>

    <!-- Search Modal -->
    <div id="search-modal" class="hidden fixed inset-0 z-50">
        <div class="absolute inset-0 bg-slate-900/70 backdrop-blur-sm" onclick="closeSearchModal()"></div>
        <div class="relative mx-auto mt-16 w-11/12 max-w-5xl bg-slate-900 border border-slate-700 rounded-lg shadow-2xl">
            <div class="flex items-center justify-between p-4 border-b border-slate-700">
                <h3 class="text-lg font-semibold">Search Sounds</h3>
                <button onclick="closeSearchModal()" class="px-3 py-1 bg-slate-700 hover:bg-slate-600 rounded">Close</button>
            </div>
            <div class="p-4">
                <input id="search-input" type="text" placeholder="Type to search..." oninput="performSearch(this.value)" class="w-full px-3 py-2 bg-slate-800 border border-slate-700 rounded focus:outline-none focus:ring-2 focus:ring-purple-500" />
            </div>
            <div id="search-results" class="p-2 pb-4 max-h-80 overflow-y-auto scroll-area"></div>
        </div>
    </div>

    <!-- Sessions Modal -->
    <div id="sessions-modal" class="hidden fixed inset-0 z-50">
        <div class="absolute inset-0 bg-slate-900/70 backdrop-blur-sm" onclick="closeSessionsModal()"></div>
        <div class="relative mx-auto mt-16 w-11/12 max-w-3xl bg-slate-900 border border-slate-700 rounded-lg shadow-2xl">
            <div class="flex items-center justify-between p-4 border-b border-slate-700">
                <h3 class="text-lg font-semibold">Manage Game Sessions</h3>
                <button onclick="closeSessionsModal()" class="px-3 py-1 bg-slate-700 hover:bg-slate-600 rounded">Close</button>
            </div>
            <div class="p-4 flex items-center gap-2">
                <input id="session-name-input" type="text" placeholder="New game session name" class="flex-1 px-3 py-2 bg-slate-800 border border-slate-700 rounded focus:outline-none focus:ring-2 focus:ring-purple-500" />
                <button onclick="createSessionFromModal()" class="px-3 py-2 rounded bg-emerald-600 hover:bg-emerald-700 text-sm">Create</button>
            </div>
            <div id="session-create-error" class="px-4 text-rose-400 text-sm hidden"></div>
            <div id="sessions-list" class="px-4 pb-4 max-h-80 overflow-y-auto"></div>
        </div>
    </div>

    <!-- Confirm Modal -->
    <div id="confirm-modal" class="hidden fixed inset-0 z-[60]">
        <div class="absolute inset-0 bg-slate-900/70 backdrop-blur-sm" onclick="closeConfirmModal()"></div>
        <div class="relative mx-auto mt-24 w-11/12 max-w-md bg-slate-900 border border-slate-700 rounded-lg shadow-2xl">
            <div class="p-4 border-b border-slate-700">
                <h3 id="confirm-title" class="text-lg font-semibold">Confirm</h3>
            </div>
            <div id="confirm-message" class="p-4 text-slate-300">Are you sure?</div>
            <div class="p-4 flex justify-end gap-2 border-t border-slate-700">
                <button onclick="closeConfirmModal()" class="px-3 py-2 rounded bg-slate-700 hover:bg-slate-600 text-sm">Cancel</button>
                <button onclick="confirmModalProceed()" class="px-3 py-2 rounded bg-red-600 hover:bg-red-700 text-sm">Confirm</button>
            </div>
        </div>
    </div>

    <!-- Rename Session Modal -->
    <div id="rename-modal" class="hidden fixed inset-0 z-50">
        <div class="absolute inset-0 bg-slate-900/70 backdrop-blur-sm" onclick="closeRenameModal()"></div>
        <div class="relative mx-auto mt-24 w-11/12 max-w-md bg-slate-900 border border-slate-700 rounded-lg shadow-2xl">
            <div class="p-4 border-b border-slate-700">
                <h3 class="text-lg font-semibold">Rename Game Session</h3>
            </div>
            <div class="p-4">
                <input id="rename-input" type="text" placeholder="Game session name" class="w-full px-3 py-2 bg-slate-800 border border-slate-700 rounded focus:outline-none focus:ring-2 focus:ring-purple-500" />
                <div id="rename-error" class="mt-2 text-rose-400 text-sm hidden"></div>
            </div>
            <div class="p-4 flex justify-end gap-2 border-t border-slate-700">
                <button onclick="closeRenameModal()" class="px-3 py-2 rounded bg-slate-700 hover:bg-slate-600 text-sm">Cancel</button>
                <button onclick="saveRenameSession()" class="px-3 py-2 rounded bg-emerald-600 hover:bg-emerald-700 text-sm">Save</button>
            </div>
        </div>
    </div>

    <!-- Rename Group Modal -->
    <div id="rename-group-modal" class="hidden fixed inset-0 z-[60]">
        <div class="absolute inset-0 bg-slate-900/70 backdrop-blur-sm" onclick="closeRenameGroupModal()"></div>
        <div class="relative mx-auto mt-24 w-11/12 max-w-md bg-slate-900 border border-slate-700 rounded-lg shadow-2xl">
            <div class="p-4 border-b border-slate-700">
                <h3 class="text-lg font-semibold">Rename Scene</h3>
            </div>
            <div class="p-4">
                <input id="rename-group-input" type="text" placeholder="Scene name" class="w-full px-3 py-2 bg-slate-800 border border-slate-700 rounded focus:outline-none focus:ring-2 focus:ring-purple-500" />
                <div id="rename-group-error" class="mt-2 text-rose-400 text-sm hidden"></div>
            </div>
            <div class="p-4 flex justify-end gap-2 border-t border-slate-700">
                <button onclick="closeRenameGroupModal()" class="px-3 py-2 rounded bg-slate-700 hover:bg-slate-600 text-sm">Cancel</button>
                <button onclick="saveRenameGroup()" class="px-3 py-2 rounded bg-emerald-600 hover:bg-emerald-700 text-sm">Save</button>
            </div>
        </div>
    </div>

    <!-- Info Modal -->
    <div id="info-modal" class="hidden fixed inset-0 z-50">
        <div class="absolute inset-0 bg-slate-900/70 backdrop-blur-sm" onclick="closeInfoModal()"></div>
        <div class="relative mx-auto mt-12 w-11/12 max-w-3xl bg-slate-900 border border-slate-700 rounded-lg shadow-2xl max-h-[80vh] flex flex-col">
            <div class="flex items-center justify-between p-4 border-b border-slate-700 flex-shrink-0">
                <h3 class="text-lg font-semibold">Info & Help</h3>
                <button onclick="closeInfoModal()" class="px-3 py-1 bg-slate-700 hover:bg-slate-600 rounded">Close</button>
            </div>
            <div class="p-4 space-y-4 text-sm md:text-base overflow-y-auto flex-1 scroll-area">
                <div>
                    <h4 class="font-semibold mb-1">Playing Sounds</h4>
                    <ul class="list-disc pl-5 text-slate-300">
                        <li>Tap anywhere on a sound card to Play/Pause. Cards turn green when playing.</li>
                        <li>Use the Loop button to repeat sounds automatically.</li>
                        <li>Priority mode reduces other sounds to 30% volume while priority sound plays.</li>
                        <li>Volume is remembered for each sound when replayed.</li>
                        <li>Active Sounds bar at the bottom shows all playing sounds with controls.</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-semibold mb-1">Quick Actions</h4>
                    <ul class="list-disc pl-5 text-slate-300">
                        <li><strong>Search:</strong> Find sounds by name, icon, or category. Also available in Scenes and Presets modals.</li>
                        <li><strong>Dice:</strong> Roll d4, d6, d8, d10, d12, d20, or d100 with animation.</li>
                        <li><strong>Coin:</strong> Flip a coin with animation. Use "Flip Again" to flip multiple times.</li>
                        <li><strong>Scenes:</strong> Create groups of sounds that play together with preset volumes and delays.</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-semibold mb-1">Favourites & Game Sessions</h4>
                    <ul class="list-disc pl-5 text-slate-300">
                        <li>Star any sound to add it to Favourites for quick access.</li>
                        <li>Favourites are saved per Game Session. Create multiple sessions for different games.</li>
                        <li>Use Game Sessions to switch between saved sound sets.</li>
                        <li>Category star icon favourites/unfavourites all sounds in that category.</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-semibold mb-1">Scenes</h4>
                    <ul class="list-disc pl-5 text-slate-300">
                        <li>Create Scenes to group multiple sounds that play together.</li>
                        <li>Set default volumes for each sound in a scene for perfect mixing.</li>
                        <li>Add delays (0-30 seconds) to individual sounds for staggered playback.</li>
                        <li>Enable Loop to continuously replay all sounds in a scene (delayed sounds play once).</li>
                        <li>Load default scenes for quick setup, or create your own custom scenes.</li>
                        <li>Search within the edit scene modal to quickly find sounds to add.</li>
                        <li>Search scenes by name in the scenes modal to find them quickly.</li>
                        <li>Tap a scene card to play all sounds with their preset volumes and delays.</li>
                        <li>Edit, rename, or delete scenes anytime. Export/import scenes with your favourites.</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-semibold mb-1">Presets</h4>
                    <ul class="list-disc pl-5 text-slate-300">
                        <li>Presets quickly load curated sound sets for specific game themes.</li>
                        <li>Includes game-specific presets (Gloomhaven, Everdell, Night Cage, etc.).</li>
                        <li>Search presets by name or description to find them quickly.</li>
                        <li>Applying a preset adds sounds to favourites and expands relevant categories.</li>
                        <li>Tap a preset card to apply it instantly.</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-semibold mb-1">Import/Export</h4>
                    <ul class="list-disc pl-5 text-slate-300">
                        <li>Export downloads favourites and scenes (including volumes, delays, and loop settings) as JSON.</li>
                        <li>Import restores favourites and scenes from a JSON file.</li>
                        <li>Exported files include sound names, scene volumes, delays, and loop states.</li>
                        <li>Unknown sound names are skipped with a notification.</li>
                        <li>Duplicate names in imports are automatically deduplicated.</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-semibold mb-1">Keyboard Shortcuts (PC)</h4>
                    <ul class="list-disc pl-5 text-slate-300">
                        <li><strong>Space:</strong> Play/Pause all active sounds</li>
                        <li><strong>S:</strong> Stop all sounds</li>
                        <li><strong>/:</strong> Open search</li>
                        <li><strong>1-9:</strong> Play favourite sound at that position</li>
                        <li><strong>Escape:</strong> Close any modal</li>
                    </ul>
                </div>
                <div>
                    <h4 class="font-semibold mb-1">Tips</h4>
                    <ul class="list-disc pl-5 text-slate-300">
                        <li>Use Expand/Collapse All to quickly browse categories.</li>
                        <li>Active bar can be expanded to half screen for easier control.</li>
                        <li>Long-press or hover on buttons for tooltips.</li>
                        <li>All data is saved locally in your browser.</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>

    <!-- Notice Modal -->
    <div id="notice-modal" class="hidden fixed inset-0 z-50">
        <div class="absolute inset-0 bg-slate-900/70 backdrop-blur-sm" onclick="closeNotice()"></div>
        <div class="relative mx-auto mt-24 w-11/12 max-w-md bg-slate-900 border border-slate-700 rounded-lg shadow-2xl">
            <div class="p-4 border-b border-slate-700">
                <h3 class="text-lg font-semibold">Notice</h3>
            </div>
            <div id="notice-message" class="p-4 text-slate-300">Done.</div>
            <div class="p-4 flex justify-end gap-2 border-t border-slate-700">
                <button onclick="closeNotice()" class="px-3 py-2 rounded bg-slate-700 hover:bg-slate-600 text-sm">OK</button>
            </div>
        </div>
    </div>

    <!-- Import Modal -->
    <div id="import-modal" class="hidden fixed inset-0 z-50">
        <div class="absolute inset-0 bg-slate-900/70 backdrop-blur-sm" onclick="closeIOModal()"></div>
        <div class="relative mx-auto mt-16 w-11/12 max-w-md bg-slate-900 border border-slate-700 rounded-lg shadow-2xl">
            <div class="flex items-center justify-between p-4 border-b border-slate-700">
                <h3 class="text-lg font-semibold" id="io-title">Import game session</h3>
                <button onclick="closeIOModal()" class="px-3 py-1 bg-slate-700 hover:bg-slate-600 rounded">Close</button>
            </div>
            <div class="p-4 space-y-4">
                <div>
                    <h4 class="font-semibold mb-2">Import game session</h4>
                    <input id="import-file" type="file" accept="application/json" class="block w-full text-sm text-slate-300" />
                    <div id="import-error" class="mt-2 text-rose-400 text-sm hidden"></div>
                    <div class="mt-3 flex justify-end">
                        <button onclick="importFavoritesFromInput()" class="px-3 py-2 rounded bg-purple-600 hover:bg-purple-700 text-sm">Import</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Sound Groups Modal -->
    <div id="groups-modal" class="hidden fixed inset-0 z-50">
        <div class="absolute inset-0 bg-slate-900/70 backdrop-blur-sm" onclick="closeGroupsModal()"></div>
        <div class="relative mx-auto mt-16 w-11/12 max-w-4xl bg-slate-900 border border-slate-700 rounded-lg shadow-2xl max-h-[80vh] flex flex-col">
            <div class="p-4 border-b border-slate-700 flex-shrink-0">
                <h3 class="text-lg font-semibold mb-2">Scenes</h3>
                <div class="flex flex-wrap gap-2">
                    <button onclick="loadDefaultScenes()" class="px-3 py-2 bg-blue-600 hover:bg-blue-700 rounded text-sm">Load Default Scenes</button>
                    <button onclick="openCreateGroupModal()" class="px-3 py-2 bg-emerald-600 hover:bg-emerald-700 rounded text-sm">Create Scene</button>
                    <button onclick="openConfirmClearAllScenes()" class="px-3 py-2 bg-amber-600 hover:bg-amber-700 rounded text-sm">Clear All</button>
                    <button onclick="closeGroupsModal()" class="px-3 py-2 bg-slate-700 hover:bg-slate-600 rounded text-sm">Close</button>
                </div>
            </div>
            <div class="p-4 border-b border-slate-700 flex-shrink-0">
                <input id="groups-search-input" type="text" placeholder="Search scenes..." oninput="performSceneSearch(this.value)" class="w-full px-3 py-2 bg-slate-800 border border-slate-700 rounded focus:outline-none focus:ring-2 focus:ring-purple-500" />
            </div>
            <div id="groups-list" class="p-4 overflow-y-auto flex-1 scroll-area"></div>
        </div>
    </div>

    <!-- Create Group Modal -->
    <div id="create-group-modal" class="hidden fixed inset-0 z-50">
        <div class="absolute inset-0 bg-slate-900/70 backdrop-blur-sm" onclick="closeCreateGroupModal()"></div>
        <div class="relative mx-auto mt-16 w-11/12 max-w-3xl bg-slate-900 border border-slate-700 rounded-lg shadow-2xl max-h-[80vh] flex flex-col">
            <div class="flex items-center justify-between p-4 border-b border-slate-700 flex-shrink-0">
                <h3 class="text-lg font-semibold">Create Scene</h3>
                <button onclick="closeCreateGroupModal()" class="px-3 py-1 bg-slate-700 hover:bg-slate-600 rounded">Close</button>
            </div>
            <div class="p-4 space-y-4 flex-1 overflow-y-auto scroll-area">
                <div>
                    <label class="block text-sm font-medium mb-2">Scene Name</label>
                    <input id="group-name-input" type="text" placeholder="e.g., Tavern Atmosphere" class="w-full px-3 py-2 bg-slate-800 border border-slate-700 rounded focus:outline-none focus:ring-2 focus:ring-purple-500" />
                    <div id="group-name-error" class="mt-2 text-rose-400 text-sm hidden"></div>
                </div>
                <div>
                    <label class="block text-sm font-medium mb-2">Search Sounds</label>
                    <input id="group-search-input" type="text" placeholder="Search sounds..." oninput="performGroupSearch(this.value)" class="w-full px-3 py-2 bg-slate-800 border border-slate-700 rounded focus:outline-none focus:ring-2 focus:ring-purple-500" />
                    <div id="group-search-results" class="mt-2 max-h-48 overflow-y-auto scroll-area border border-slate-700 rounded hidden"></div>
                </div>
                <div>
                    <label class="block text-sm font-medium mb-2">Select Sounds</label>
                    <div id="group-sounds-list" class="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 gap-2 max-h-96 overflow-y-auto scroll-area border border-slate-700 rounded p-3"></div>
                </div>
                <div id="group-volumes-section" class="hidden">
                    <label class="block text-sm font-medium mb-2">Set Default Volumes</label>
                    <div id="group-volumes-list" class="space-y-2 max-h-64 overflow-y-auto scroll-area border border-slate-700 rounded p-3"></div>
                </div>
                <div class="flex justify-end gap-2">
                    <button onclick="closeCreateGroupModal()" class="px-3 py-2 rounded bg-slate-700 hover:bg-slate-600 text-sm">Cancel</button>
                    <button onclick="saveSoundGroup()" class="px-3 py-2 rounded bg-emerald-600 hover:bg-emerald-700 text-sm">Save Scene</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Dice Modal -->
    <div id="dice-modal" class="hidden fixed inset-0 z-50">
        <div class="absolute inset-0 bg-slate-900/70 backdrop-blur-sm" onclick="closeDiceModal()"></div>
        <div class="relative mx-auto mt-16 w-11/12 max-w-md bg-slate-900 border border-slate-700 rounded-lg shadow-2xl">
            <div class="flex items-center justify-between p-4 border-b border-slate-700">
                <h3 class="text-lg font-semibold">Dice Roll</h3>
                <button onclick="closeDiceModal()" class="px-3 py-1 bg-slate-700 hover:bg-slate-600 rounded">Close</button>
            </div>
            <div class="p-4 space-y-4">
                <div class="grid grid-cols-3 gap-3">
                    <button onclick="rollDice(4)" class="px-4 py-3 bg-slate-800 hover:bg-slate-700 rounded-lg border border-slate-700 transition-colors">
                        <div class="text-2xl mb-1">ğŸ²</div>
                        <div class="text-sm font-medium">d4</div>
                    </button>
                    <button onclick="rollDice(6)" class="px-4 py-3 bg-slate-800 hover:bg-slate-700 rounded-lg border border-slate-700 transition-colors">
                        <div class="text-2xl mb-1">ğŸ²</div>
                        <div class="text-sm font-medium">d6</div>
                    </button>
                    <button onclick="rollDice(8)" class="px-4 py-3 bg-slate-800 hover:bg-slate-700 rounded-lg border border-slate-700 transition-colors">
                        <div class="text-2xl mb-1">ğŸ²</div>
                        <div class="text-sm font-medium">d8</div>
                    </button>
                    <button onclick="rollDice(10)" class="px-4 py-3 bg-slate-800 hover:bg-slate-700 rounded-lg border border-slate-700 transition-colors">
                        <div class="text-2xl mb-1">ğŸ²</div>
                        <div class="text-sm font-medium">d10</div>
                    </button>
                    <button onclick="rollDice(12)" class="px-4 py-3 bg-slate-800 hover:bg-slate-700 rounded-lg border border-slate-700 transition-colors">
                        <div class="text-2xl mb-1">ğŸ²</div>
                        <div class="text-sm font-medium">d12</div>
                    </button>
                    <button onclick="rollDice(20)" class="px-4 py-3 bg-slate-800 hover:bg-slate-700 rounded-lg border border-slate-700 transition-colors">
                        <div class="text-2xl mb-1">ğŸ²</div>
                        <div class="text-sm font-medium">d20</div>
                    </button>
                    <button onclick="rollDice(100)" class="px-4 py-3 bg-slate-800 hover:bg-slate-700 rounded-lg border border-slate-700 transition-colors col-span-3">
                        <div class="text-2xl mb-1">ğŸ²</div>
                        <div class="text-sm font-medium">d100</div>
                    </button>
                </div>
                <div id="dice-result" class="text-center py-4 min-h-[120px] flex flex-col items-center justify-center gap-2 dice-container"></div>
                <div id="coin-flip-again" class="hidden text-center pb-2">
                    <button onclick="flipCoin()" class="px-6 py-2 bg-amber-600 hover:bg-amber-700 rounded-lg border border-amber-500 transition-colors text-white font-medium">
                        ğŸª™ Flip Again
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Icons as SVG strings
        const icons = {
            play: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="5 3 19 12 5 21 5 3"></polygon></svg>',
            pause: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="6" y="4" width="4" height="16"></rect><rect x="14" y="4" width="4" height="16"></rect></svg>',
            square: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect></svg>',
            repeat: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="17 1 21 5 17 9"></polyline><path d="M3 11V9a4 4 0 0 1 4-4h14"></path><polyline points="7 23 3 19 7 15"></polyline><path d="M21 13v2a4 4 0 0 1-4 4H3"></path></svg>',
            repeat1: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="17 1 21 5 17 9"></polyline><path d="M3 11V9a4 4 0 0 1 4-4h14"></path><polyline points="7 23 3 19 7 15"></polyline><path d="M21 13v2a4 4 0 0 1-4 4H3"></path><path d="M11 10h1v4"></path></svg>',
            volume: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"></path></svg>',
            star: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"></polygon></svg>',
            starFilled: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"></polygon></svg>',
            x: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>',
            refresh: '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="23 4 23 10 17 10"></polyline><polyline points="1 20 1 14 7 14"></polyline><path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path></svg>'
        };

        // Sound Library Configuration - EDIT THIS TO ADD/REMOVE SOUNDS
        const soundLibrary = {
    'Tavern & Inn': [
        { id: 'tavern-crowd', name: 'Tavern Crowd', url: '/sounds/tavern/crowd.wav', icon: 'ğŸº' },
        { id: 'tavern-music', name: 'Music', url: '/sounds/tavern/music.flac', icon: 'ğŸµ' },
        { id: 'fireplace', name: 'Fireplace Crackle', url: '/sounds/tavern/fireplace.wav', icon: 'ğŸ”¥' },
        { id: 'pouring-ale', name: 'Pouring Ale', url: '/sounds/tavern/ale.wav', icon: 'ğŸ»' },
        { id: 'dice-roll', name: 'Dice on Table', url: '/sounds/tavern/dice.mp3', icon: 'ğŸ²' },
        { id: 'chair-scrape', name: 'Chair Scraping', url: '/sounds/tavern/chair.mp3', icon: 'ğŸª‘' },
        { id: 'bard-song 1', name: 'Bard Song 1', url: '/sounds/tavern/bard1.wav', icon: 'ğŸ¤' },
		{ id: 'bard-song 2', name: 'Bard Song 2', url: '/sounds/tavern/bard2.wav', icon: 'ğŸ¤' },
        { id: 'mug-clink', name: 'Mugs Clinking', url: '/sounds/tavern/mugs.wav', icon: 'ğŸº' },
        { id: 'fiddle-tune', name: 'Fiddle Tune', url: '/sounds/tavern/fiddle.wav', icon: 'ğŸ»' },
        { id: 'plate-clatter', name: 'Plates Clattering', url: '/sounds/tavern/plate.wav', icon: 'ğŸ½ï¸' },
        { id: 'tavern-cheer', name: 'Tavern Cheer', url: '/sounds/tavern/cheer.wav', icon: 'ğŸ¥‚' },
        { id: 'door-open-tavern', name: 'Door Opens', url: '/sounds/tavern/door.wav', icon: 'ğŸšª' }
    ],
    
    'Combat & Battle': [
        { id: 'sword-clash', name: 'Sword Clash', url: '/sounds/combat/sword-clash.mp3', icon: 'âš”ï¸' },
        { id: 'sword-swing', name: 'Sword Swing', url: '/sounds/combat/swing.wav', icon: 'ğŸ—¡ï¸' },
        { id: 'arrow-shot', name: 'Arrow Release', url: '/sounds/combat/arrow.wav', icon: 'ğŸ¹' },
        { id: 'shield-block', name: 'Shield Block', url: '/sounds/combat/shield.wav', icon: 'ğŸ›¡ï¸' },
        { id: 'battle-cry1', name: 'Battle Cry 1', url: '/sounds/combat/cry1.mp3', icon: 'ğŸ˜¤' },
		{ id: 'battle-cry2', name: 'Battle Cry 2', url: '/sounds/combat/cry2.wav', icon: 'ğŸ˜¤' },
        { id: 'war-drum', name: 'War Drums', url: '/sounds/combat/drums.wav', icon: 'ğŸ¥' },
        { id: 'shield-drop', name: 'Shield Drop', url: '/sounds/combat/shield-drop.wav', icon: 'ğŸ›¡ï¸' },
		{ id: 'dying', name: 'Dying', url: '/sounds/combat/dying.wav', icon: 'ğŸ’€' }
    ],
    
    'Magic & Spells': [
        { id: 'fireball', name: 'Fireball', url: '/sounds/magic/fireball.wav', icon: 'ğŸ”¥' },
        { id: 'ice-spell', name: 'Ice Spell', url: '/sounds/magic/ice.wav', icon: 'â„ï¸' },
        { id: 'lightning', name: 'Lightning Bolt', url: '/sounds/magic/lightning.wav', icon: 'âš¡' },
        { id: 'heal-spell', name: 'Healing Spell', url: '/sounds/magic/heal.wav', icon: 'âœ¨' },
        { id: 'teleport', name: 'Teleport', url: '/sounds/magic/teleport.wav', icon: 'ğŸ’«' },
        { id: 'magic-shield', name: 'Magic Shield', url: '/sounds/magic/shield.wav', icon: 'ğŸ”®' },
        { id: 'enchant', name: 'Enchantment', url: '/sounds/magic/enchant.wav', icon: 'âœ´ï¸' },
        { id: 'dark-magic', name: 'Dark Magic', url: '/sounds/magic/dark.wav', icon: 'ğŸŒ‘' },
        { id: 'chaos-surge', name: 'Chaos Surge', url: '/sounds/magic/chaos.wav', icon: 'ğŸŒ€' },
        { id: 'whisper-ritual', name: 'Whispered Ritual', url: '/sounds/magic/ritual-whisper.wav', icon: 'ğŸ—ï¸' },
        { id: 'summon', name: 'Summoning', url: '/sounds/magic/summon.wav', icon: 'ğŸ§¿' },
        { id: 'dispel', name: 'Dispel Magic', url: '/sounds/magic/dispel.wav', icon: 'ğŸŒ€' }
    ],
    
    'Dungeon & Cave': [
        { id: 'dungeon-ambience', name: 'Dungeon Ambience', url: '/sounds/dungeon/ambience.wav', icon: 'ğŸ°' },
        { id: 'water-drip', name: 'Water Dripping', url: '/sounds/dungeon/drip.wav', icon: 'ğŸ’§' },
        { id: 'chains', name: 'Rattling Chains', url: '/sounds/dungeon/chains.wav', icon: 'â›“ï¸' },
        { id: 'stone-door', name: 'Stone Door', url: '/sounds/dungeon/stone-door.wav', icon: 'ğŸšª' },
        { id: 'torch', name: 'Torch Burning', url: '/sounds/dungeon/torch.wav', icon: 'ğŸ”¦' },
        { id: 'echo-steps', name: 'Echoing Steps', url: '/sounds/dungeon/echo.wav', icon: 'ğŸ‘£' },
        { id: 'trap-trigger', name: 'Trap Triggered', url: '/sounds/dungeon/trap.wav', icon: 'âš ï¸' },
        { id: 'cave-in', name: 'Cave-In Rumble', url: '/sounds/dungeon/cavein.wav', icon: 'ğŸª¨' },
        { id: 'door-iron', name: 'Iron Gate', url: '/sounds/dungeon/iron-gate.wav', icon: 'ğŸ—ï¸' },
        { id: 'torch-extinguish', name: 'Torch Extinguish', url: '/sounds/dungeon/torch-out.wav', icon: 'ğŸ•¯ï¸' },
        { id: 'rat-scurries', name: 'Rats Scurrying', url: '/sounds/dungeon/rats.wav', icon: 'ğŸ€' },
        { id: 'pickaxe', name: 'Pickaxe Strikes', url: '/sounds/dungeon/pickaxe.wav', icon: 'â›ï¸' }
    ],
    
    'Forest & Nature': [
        { id: 'forest-ambience', name: 'Forest Ambience', url: '/sounds/forest/ambience.wav', icon: 'ğŸŒ²' },
        { id: 'birds', name: 'Bird Calls', url: '/sounds/forest/birds.wav', icon: 'ğŸ¦' },
        { id: 'stream', name: 'Babbling Stream', url: '/sounds/forest/stream.wav', icon: 'ğŸŒŠ' },
        { id: 'wind-leaves', name: 'Wind in Leaves', url: '/sounds/forest/wind.wav', icon: 'ğŸƒ' },
        { id: 'owl', name: 'Owl Hoot', url: '/sounds/forest/owl.wav', icon: 'ğŸ¦‰' },
        { id: 'rustling', name: 'Bush Rustling', url: '/sounds/forest/rustle.wav', icon: 'ğŸŒ¿' },
        { id: 'crickets', name: 'Night Crickets', url: '/sounds/forest/crickets.wav', icon: 'ğŸ¦—' },
        { id: 'squirrel', name: 'Squirrel Chatter', url: '/sounds/forest/squirrel.wav', icon: 'ğŸ¿ï¸' },
        { id: 'bees', name: 'Bees Nearby', url: '/sounds/forest/bees.wav', icon: 'ğŸ' },
        { id: 'thunderbirds', name: 'Distant Thunderbirds', url: '/sounds/forest/thunderbirds.wav', icon: 'ğŸ¦…' },
        { id: 'deer', name: 'Deer Rustle', url: '/sounds/forest/deer.wav', icon: 'ğŸ¦Œ' }
    ],
    
    'Creatures & Monsters': [
        { id: 'dragon-roar', name: 'Dragon Roar', url: '/sounds/creatures/dragon.wav', icon: 'ğŸ‰' },
        { id: 'wolf-howl', name: 'Wolf Howl', url: '/sounds/creatures/wolf.wav', icon: 'ğŸº' },
        { id: 'zombie', name: 'Zombie Groan', url: '/sounds/creatures/zombie.wav', icon: 'ğŸ§Ÿ' },
        { id: 'skeleton', name: 'Skeleton Rattle', url: '/sounds/creatures/skeleton.wav', icon: 'ğŸ’€' },
        { id: 'ghost', name: 'Ghost Wail', url: '/sounds/creatures/ghost.wav', icon: 'ğŸ‘»' },
        { id: 'goblin', name: 'Goblin Screech', url: '/sounds/creatures/goblin.wav', icon: 'ğŸ‘º' },
        { id: 'troll', name: 'Troll Growl', url: '/sounds/creatures/troll.wav', icon: 'ğŸ‘¹' },
        { id: 'spider', name: 'Giant Spider', url: '/sounds/creatures/spider.wav', icon: 'ğŸ•·ï¸' },
        { id: 'bat-swarm', name: 'Bat Swarm', url: '/sounds/creatures/bats.wav', icon: 'ğŸ¦‡' },
        { id: 'snake-hiss', name: 'Snake Hiss', url: '/sounds/creatures/snake.wav', icon: 'ğŸ' },
        { id: 'rat-squeak', name: 'Rat Squeaks', url: '/sounds/creatures/rats.wav', icon: 'ğŸ€' },
        { id: 'slime', name: 'Slime Squish', url: '/sounds/creatures/slime.wav', icon: 'ğŸ«§' },
        { id: 'ogre', name: 'Ogre Roar', url: '/sounds/creatures/ogre.wav', icon: 'ğŸ§Œ' },
        { id: 'witch', name: 'Witch Cackle', url: '/sounds/creatures/witch.wav', icon: 'ğŸ§™' }
    ],
    
    'Weather & Elements': [
        { id: 'rain-light', name: 'Light Rain', url: '/sounds/weather/light-rain.wav', icon: 'ğŸŒ§ï¸' },
        { id: 'rain-heavy', name: 'Heavy Rainstorm', url: '/sounds/weather/heavy-rain.wav', icon: 'â›ˆï¸' },
        { id: 'thunder', name: 'Thunder Clap', url: '/sounds/weather/thunder.wav', icon: 'âš¡' },
        { id: 'wind-gentle', name: 'Gentle Breeze', url: '/sounds/weather/breeze.wav', icon: 'ğŸ’¨' },
        { id: 'wind-storm', name: 'Windstorm', url: '/sounds/weather/windstorm.wav', icon: 'ğŸŒªï¸' },
        { id: 'snow', name: 'Snowstorm', url: '/sounds/weather/snow.wav', icon: 'â„ï¸' },
        { id: 'fog', name: 'Eerie Fog', url: '/sounds/weather/fog.wav', icon: 'ğŸŒ«ï¸' },
        { id: 'hail', name: 'Hail', url: '/sounds/weather/hail.wav', icon: 'ğŸ§Š' },
        { id: 'distant-wind', name: 'Distant Wind', url: '/sounds/weather/distant-wind.wav', icon: 'ğŸŒ¬ï¸' },
        { id: 'earthquake', name: 'Earthquake Rumble', url: '/sounds/weather/earthquake.wav', icon: 'ğŸŒ' }
    ],
    
    'City & Town': [
        { id: 'marketplace', name: 'Marketplace', url: '/sounds/city/market.wav', icon: 'ğŸª' },
        { id: 'town-square', name: 'Town Square', url: '/sounds/city/square.wav', icon: 'ğŸ›ï¸' },
        { id: 'bell-tower', name: 'Church Bells', url: '/sounds/city/bells.wav', icon: 'ğŸ””' },
        { id: 'harbor', name: 'Harbor Docks', url: '/sounds/city/harbor.wav', icon: 'âš“' },
        { id: 'blacksmith', name: 'Blacksmith', url: '/sounds/city/blacksmith.wav', icon: 'âš’ï¸' },
        { id: 'crowd', name: 'City Crowd', url: '/sounds/city/crowd.wav', icon: 'ğŸ‘¥' },
        { id: 'horse-cart', name: 'Horse Cart', url: '/sounds/city/cart.wav', icon: 'ğŸ´' },
        { id: 'guard-halt', name: 'Guard: Halt!', url: '/sounds/city/guard.wav', icon: 'ğŸ›¡ï¸' },
        { id: 'town-crier', name: 'Town Crier', url: '/sounds/city/crier.wav', icon: 'ğŸ“£' },
        { id: 'market-haggle', name: 'Haggling', url: '/sounds/city/haggle.wav', icon: 'ğŸ—£ï¸' },
        { id: 'cart-wheels', name: 'Cart Wheels', url: '/sounds/city/wheels.wav', icon: 'ğŸ›' }
    ],
    
    'Ocean & Sea': [
        { id: 'ocean-waves', name: 'Ocean Waves', url: '/sounds/ocean/waves.wav', icon: 'ğŸŒŠ' },
        { id: 'seagulls', name: 'Seagulls', url: '/sounds/ocean/seagulls.wav', icon: 'ğŸ¦…' },
        { id: 'ship-creak', name: 'Ship Creaking', url: '/sounds/ocean/ship.wav', icon: 'â›µ' },
        { id: 'underwater', name: 'Underwater', url: '/sounds/ocean/underwater.wav', icon: 'ğŸŒ€' },
        { id: 'whale', name: 'Whale Song', url: '/sounds/ocean/whale.wav', icon: 'ğŸ‹' },
        { id: 'storm-at-sea', name: 'Storm at Sea', url: '/sounds/ocean/storm.wav', icon: 'ğŸŒŠ' },
        { id: 'rigging', name: 'Rigging and Ropes', url: '/sounds/ocean/rigging.wav', icon: 'ğŸª¢' },
        { id: 'deck-steps', name: 'Deck Footsteps', url: '/sounds/ocean/deck.wav', icon: 'ğŸ‘£' },
        { id: 'ship-bell', name: 'Ship Bell', url: '/sounds/ocean/bell.wav', icon: 'ğŸ””' }
    ],
    
    'Items & Objects': [
        { id: 'coins', name: 'Coins Jingling', url: '/sounds/items/coins.wav', icon: 'ğŸ’°' },
        { id: 'chest-open', name: 'Chest Opening', url: '/sounds/items/chest.wav', icon: 'ğŸ“¦' },
        { id: 'key-turn', name: 'Key in Lock', url: '/sounds/items/key.wav', icon: 'ğŸ”‘' },
        { id: 'potion-drink', name: 'Drinking Potion', url: '/sounds/items/potion.wav', icon: 'ğŸ§ª' },
        { id: 'page-turn', name: 'Page Turning', url: '/sounds/items/page.wav', icon: 'ğŸ“–' },
        { id: 'quill-write', name: 'Quill Writing', url: '/sounds/items/quill.wav', icon: 'ğŸª¶' },
        { id: 'glass-break', name: 'Glass Breaking', url: '/sounds/items/glass.wav', icon: 'ğŸ’¥' },
        { id: 'bag-drop', name: 'Heavy Bag Drop', url: '/sounds/items/bag.wav', icon: 'ğŸ’' },
        { id: 'lock-click', name: 'Lock Click', url: '/sounds/items/lock-click.wav', icon: 'ğŸ—ï¸' },
        { id: 'ink-scratch', name: 'Ink Scratch', url: '/sounds/items/ink.wav', icon: 'âœ’ï¸' },
        { id: 'coin-drop', name: 'Coin Drop', url: '/sounds/items/coin-drop.wav', icon: 'ğŸª™' },
        { id: 'rope', name: 'Rope Uncoil', url: '/sounds/items/rope.wav', icon: 'ğŸª¢' }
    ],
    
    'Doors & Movement': [
        { id: 'door-creak', name: 'Door Creaking', url: '/sounds/doors/creak.wav', icon: 'ğŸšª' },
        { id: 'door-slam', name: 'Door Slam', url: '/sounds/doors/slam.wav', icon: 'ğŸ’¥' },
        { id: 'footsteps-wood', name: 'Footsteps on Wood', url: '/sounds/doors/wood-steps.wav', icon: 'ğŸ‘£' },
        { id: 'footsteps-stone', name: 'Footsteps on Stone', url: '/sounds/doors/stone-steps.wav', icon: 'ğŸ¦¶' },
        { id: 'running', name: 'Running Footsteps', url: '/sounds/doors/running.wav', icon: 'ğŸƒ' },
        { id: 'stairs', name: 'Climbing Stairs', url: '/sounds/doors/stairs.wav', icon: 'ğŸªœ' },
        { id: 'stealth-steps', name: 'Stealthy Steps', url: '/sounds/doors/stealth.wav', icon: 'ğŸ«¥' },
        { id: 'ladder', name: 'Climb Ladder', url: '/sounds/doors/ladder.wav', icon: 'ğŸªœ' },
        { id: 'window-open', name: 'Window Open', url: '/sounds/doors/window.wav', icon: 'ğŸªŸ' }
    ],
    
    'Horror & Suspense': [
        { id: 'heartbeat', name: 'Heartbeat', url: '/sounds/horror/heartbeat.wav', icon: 'â¤ï¸' },
		{ id: 'heartbeat-fast', name: 'Heartbeat Fast', url: '/sounds/horror/heartbeat-fast.wav', icon: 'ğŸ’”' },
		{ id: 'heartbeat-slowing', name: 'Heartbeat Slowing', url: '/sounds/horror/heartbeat-slowing.wav', icon: 'ğŸ’”' },
		{ id: 'ghost-whispers', name: 'Ghost Whispers', url: '/sounds/horror/ghost-whispers.wav', icon: 'ğŸ‘»' },
        { id: 'whispers', name: 'Eerie Whispers', url: '/sounds/horror/whispers.wav', icon: 'ğŸ‘¤' },
        { id: 'woman-scream', name: 'Woman Scream', url: '/sounds/horror/woman-scream.mp3', icon: 'ğŸ˜±' },
		{ id: 'man-scream', name: 'Man Scream', url: '/sounds/horror/man-scream.wav', icon: 'ğŸ˜±' },
		{ id: 'horror-scream', name: 'Horror Scream', url: '/sounds/horror/horror-scream.wav', icon: 'ğŸ—£ï¸' },
        { id: 'creepy-laugh', name: 'Creepy Laugh', url: '/sounds/horror/creepy-laugh.wav', icon: 'ğŸ˜ˆ' },
		{ id: 'witch-laugh', name: 'Witch Laugh', url: '/sounds/horror/witch-laugh.mp3', icon: 'ğŸ§™â€â™€ï¸' },
        { id: 'clock-ticking', name: 'Clock Ticking', url: '/sounds/horror/clock.wav', icon: 'ğŸ•°ï¸' },
		{ id: 'clock-chime', name: 'Clock Chime', url: '/sounds/horror/clock-chime.wav', icon: 'ğŸ•°ï¸' },
		{ id: 'music', name: 'Spooky Music', url: '/sounds/horror/music.mp3', icon: 'ğŸµ' },
        { id: 'music1', name: 'Creepy Music Box', url: '/sounds/horror/music1.mp3', icon: 'ğŸµ' },
		{ id: 'music2', name: 'Creepy Music Box 2', url: '/sounds/horror/music2.wav', icon: 'ğŸµ' },
		{ id: 'heavy-breathing', name: 'Heavy Breathing', url: '/sounds/horror/heavy-breathing.wav', icon: 'ğŸ˜®â€ğŸ’¨' },
		{ id: 'scared-breathing', name: 'Scared Breathing', url: '/sounds/horror/scared-breathing.wav', icon: 'ğŸ˜®â€ğŸ’¨' },
        { id: 'slow-breathing', name: 'Slow Breathing', url: '/sounds/horror/slow-breathing.mp3', icon: 'ğŸ˜®â€ğŸ’¨' },
        { id: 'light-match', name: 'Light Match', url: '/sounds/horror/light-match.wav', icon: 'ğŸ”¥' },
		{ id: 'flame-death', name: 'Flame Death', url: '/sounds/horror/flame-death.wav', icon: 'ğŸ”¥' },
        { id: 'unlock-door', name: 'Unlock Door', url: '/sounds/horror/unlock-door.wav', icon: 'ğŸ—' },
		{ id: 'ambience1', name: 'Ambience 1', url: '/sounds/horror/ambience1.wav', icon: 'â˜ ï¸ï¸à¼’ï¸âœï¸ğŸ•¸ğ–¤' },
		{ id: 'ambience2', name: 'Ambience 2', url: '/sounds/horror/ambience2.wav', icon: 'â˜ ï¸ï¸à¼’ï¸âœï¸ğŸ•¸ğ–¤' },
		{ id: 'ambience3', name: 'Ambience 3', url: '/sounds/horror/ambience3.wav', icon: 'â˜ ï¸ï¸à¼’ï¸âœï¸ğŸ•¸ğ–¤' },
        { id: 'chains', name: 'Chains Dragging', url: '/sounds/horror/chains.wav', icon: 'â›“ï¸' }
    ],
    
    'Sci-Fi & Futuristic': [
        { id: 'laser-shot', name: 'Laser Shot', url: '/sounds/scifi/laser.wav', icon: 'ğŸ”«' },
        { id: 'spaceship', name: 'Spaceship Hum', url: '/sounds/scifi/ship.wav', icon: 'ğŸš€' },
        { id: 'robot', name: 'Robot Beeps', url: '/sounds/scifi/robot.wav', icon: 'ğŸ¤–' },
        { id: 'alarm', name: 'Red Alert', url: '/sounds/scifi/alarm.wav', icon: 'ğŸš¨' },
        { id: 'teleporter', name: 'Teleporter', url: '/sounds/scifi/teleport.wav', icon: 'âœ¨' },
        { id: 'computer', name: 'Computer Beeps', url: '/sounds/scifi/computer.wav', icon: 'ğŸ’»' },
        { id: 'airlock', name: 'Airlock', url: '/sounds/scifi/airlock.wav', icon: 'ğŸ›°ï¸' },
        { id: 'drone', name: 'Drone Hover', url: '/sounds/scifi/drone.wav', icon: 'ğŸ›¸' }
    ],
    
    'Victory & Defeat': [
        { id: 'victory-fanfare', name: 'Victory Fanfare', url: '/sounds/victory/fanfare.wav', icon: 'ğŸº' },
        { id: 'level-up', name: 'Level Up', url: '/sounds/victory/levelup.wav', icon: 'â¬†ï¸' },
        { id: 'achievement', name: 'Achievement', url: '/sounds/victory/achievement.wav', icon: 'ğŸ†' },
        { id: 'defeat', name: 'Defeat', url: '/sounds/victory/defeat.wav', icon: 'ğŸ’€' },
        { id: 'cheer', name: 'Crowd Cheering', url: '/sounds/victory/cheer.wav', icon: 'ğŸ‰' },
        { id: 'slow-clap', name: 'Slow Clap', url: '/sounds/victory/slowclap.wav', icon: 'ğŸ‘' }
    ],
    
    'Mountains & Highlands': [
        { id: 'cold-wind', name: 'Cold Mountain Wind', url: '/sounds/mountains/wind.wav', icon: 'ğŸŒ¬ï¸' },
        { id: 'eagle-cry', name: 'Eagle Cry', url: '/sounds/mountains/eagle.wav', icon: 'ğŸ¦…' },
        { id: 'rockfall', name: 'Distant Rockfall', url: '/sounds/mountains/rockfall.wav', icon: 'ğŸª¨' },
        { id: 'mountain-stream', name: 'Mountain Stream', url: '/sounds/mountains/stream.wav', icon: 'ğŸ’§' }
    ],
    
    'Desert & Wasteland': [
        { id: 'desert-wind', name: 'Desert Wind', url: '/sounds/desert/wind.wav', icon: 'ğŸŒªï¸' },
        { id: 'sand-steps', name: 'Footsteps in Sand', url: '/sounds/desert/steps.wav', icon: 'ğŸ‘£' },
        { id: 'scorpion', name: 'Scorpion Skitter', url: '/sounds/desert/scorpion.wav', icon: 'ğŸ¦‚' },
        { id: 'mirage-tone', name: 'Mirage Tone', url: '/sounds/desert/mirage.wav', icon: 'â™¨ï¸' }
    ],

    'Arctic & Tundra': [
        { id: 'blizzard', name: 'Blizzard', url: '/sounds/arctic/blizzard.wav', icon: 'ğŸŒ¨ï¸' },
        { id: 'ice-crack', name: 'Cracking Ice', url: '/sounds/arctic/ice-crack.wav', icon: 'ğŸ§Š' },
        { id: 'polar-wind', name: 'Polar Wind', url: '/sounds/arctic/wind.wav', icon: 'ğŸ’¨' }
    ],

    'Temple & Ritual': [
        { id: 'chanting', name: 'Monk Chanting', url: '/sounds/temple/chant.wav', icon: 'ğŸ›•' },
        { id: 'gong', name: 'Gong Hit', url: '/sounds/temple/gong.wav', icon: 'ğŸ¥' },
        { id: 'bells', name: 'Ritual Bells', url: '/sounds/temple/bells.wav', icon: 'ğŸ””' }
    ],

    'Library & Study': [
        { id: 'page-turn-soft', name: 'Soft Page Turns', url: '/sounds/library/pages.wav', icon: 'ğŸ“–' },
        { id: 'quill-scratch', name: 'Quill Scratch', url: '/sounds/library/quill.wav', icon: 'âœ’ï¸' },
        { id: 'quiet-ambience', name: 'Quiet Room', url: '/sounds/library/quiet.wav', icon: 'ğŸ¤«' }
    ],

    'Workshop & Crafting': [
        { id: 'hammer-anvil', name: 'Hammer on Anvil', url: '/sounds/workshop/anvil.wav', icon: 'âš’ï¸' },
        { id: 'saw-wood', name: 'Sawing Wood', url: '/sounds/workshop/saw.wav', icon: 'ğŸªš' },
        { id: 'forge-fire', name: 'Forge Fire', url: '/sounds/workshop/forge.wav', icon: 'ğŸ”¥' }
    ],

    'Festival & Celebration': [
        { id: 'fireworks', name: 'Fireworks', url: '/sounds/festival/fireworks.wav', icon: 'ğŸ†' },
        { id: 'laughter', name: 'Laughter', url: '/sounds/festival/laughter.wav', icon: 'ğŸ˜‚' },
        { id: 'music-dance', name: 'Dance Music', url: '/sounds/festival/dance.wav', icon: 'ğŸ’ƒ' }
    ],

    'Stealth & Espionage': [
        { id: 'soft-steps', name: 'Soft Footsteps', url: '/sounds/stealth/steps.wav', icon: 'ğŸ«¥' },
        { id: 'door-pick', name: 'Lockpicking', url: '/sounds/stealth/lockpick.wav', icon: 'ğŸ—ï¸' },
        { id: 'whispered-orders', name: 'Whispered Orders', url: '/sounds/stealth/orders.wav', icon: 'ğŸ¤«' }
    ],

    'Vehicles & Travel': [
        { id: 'horse-gallop', name: 'Horse Gallop', url: '/sounds/travel/horse.wav', icon: 'ğŸ' },
        { id: 'wagon', name: 'Wagon Rattle', url: '/sounds/travel/wagon.wav', icon: 'ğŸ›' },
        { id: 'port-tavern', name: 'Port Tavern', url: '/sounds/travel/port-tavern.wav', icon: 'ğŸ»' }
    ],
};

const categoryIcons = {
    'Tavern & Inn': 'ğŸº',
    'Combat & Battle': 'âš”ï¸',
    'Magic & Spells': 'âœ¨',
    'Dungeon & Cave': 'ğŸ°',
    'Forest & Nature': 'ğŸŒ²',
    'Creatures & Monsters': 'ğŸ‰',
    'Weather & Elements': 'ğŸŒ§ï¸',
    'City & Town': 'ğŸ›ï¸',
    'Ocean & Sea': 'ğŸŒŠ',
    'Items & Objects': 'ğŸ’°',
    'Doors & Movement': 'ğŸšª',
    'Horror & Suspense': 'ğŸ˜±',
    'Sci-Fi & Futuristic': 'ğŸš€',
    'Victory & Defeat': 'ğŸ†',
    'Mountains & Highlands': 'â›°ï¸',
    'Desert & Wasteland': 'ğŸœï¸',
    'Arctic & Tundra': 'ğŸ§Š',
    'Jungle & Savannah': 'ğŸŒ´',
    'Temple & Ritual': 'ğŸ›•',
    'Library & Study': 'ğŸ“š',
    'Workshop & Crafting': 'ğŸ› ï¸',
    'Festival & Celebration': 'ğŸŠ',
    'Stealth & Espionage': 'ğŸ•µï¸',
    'Vehicles & Travel': 'ğŸ›'
};

// Buy Me a Coffee link
const BUY_ME_A_COFFEE_LINK = 'https://buymeacoffee.com/liamdouble';

// Set Buy Me a Coffee links
document.addEventListener('DOMContentLoaded', () => {
    const ribbon = document.getElementById('buy-me-coffee-ribbon');
    const footer = document.getElementById('buy-me-coffee-footer');
    if (ribbon) ribbon.href = BUY_ME_A_COFFEE_LINK;
    if (footer) footer.href = BUY_ME_A_COFFEE_LINK;
});

        // State Management
        let activeSounds = {};
        let audioElements = {};
        let audioContext = null;
        let gainNodes = {}; // Store GainNodes for iOS volume control
        let sceneTimeouts = []; // Track scene timeouts for cancellation
        let sceneIntervals = []; // Track scene intervals for cancellation
        
        // Initialize Web Audio API context (required for iOS volume control)
        function getAudioContext() {
            if (!audioContext) {
                try {
                    const AudioContextClass = window.AudioContext || window.webkitAudioContext;
                    audioContext = new AudioContextClass();
                    // Resume context if suspended (iOS requirement)
                    if (audioContext.state === 'suspended') {
                        audioContext.resume();
                    }
                } catch(e) {
                    console.warn('Web Audio API not available, falling back to HTML5 audio');
                }
            }
            return audioContext;
        }
        
        // Create gain node for a sound (iOS volume control)
        function getGainNode(soundId, audio) {
            if (!audio || !audioContext) return null;
            
            // Return existing gain node if it exists
            if (gainNodes[soundId]) {
                return gainNodes[soundId];
            }
            
            // Create new gain node
            try {
                // Ensure AudioContext is running (iOS requirement)
                if (audioContext.state === 'suspended') {
                    audioContext.resume();
                }
                
                // Create MediaElementAudioSourceNode from HTML audio element
                // This disconnects the audio from its default output
                const source = audioContext.createMediaElementSource(audio);
                const gainNode = audioContext.createGain();
                
                // Connect: source -> gain -> destination
                source.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                // Set initial volume from memory
                const savedVolume = getVolumeMemory(soundId);
                gainNode.gain.value = savedVolume;
                
                gainNodes[soundId] = { source, gainNode };
                return gainNodes[soundId];
            } catch(e) {
                // If createMediaElementSource fails (element already connected), return null
                // This can happen if the audio element was already used to create a source
                // In this case, we'll fall back to HTML5 audio volume
                console.warn(`Could not create gain node for ${soundId}:`, e);
                return null;
            }
        }
        
        // Set volume using Web Audio API (iOS compatible)
        function setVolumeViaWebAudio(soundId, volume) {
            const gainData = gainNodes[soundId];
            if (gainData && gainData.gainNode) {
                // Use Web Audio API gain node (works on iOS)
                gainData.gainNode.gain.value = volume;
                return true;
            }
            return false;
        }
let sessions = JSON.parse(localStorage.getItem('soundboard-sessions') || '[]');
let currentSessionId = JSON.parse(localStorage.getItem('soundboard-currentSessionId') || 'null');
function ensureDefaultSession() {
    if (!Array.isArray(sessions) || sessions.length === 0) {
        const def = { id: 'default', name: 'Default' };
        sessions = [def];
        localStorage.setItem('soundboard-sessions', JSON.stringify(sessions));
        localStorage.setItem('soundboard-currentSessionId', JSON.stringify(def.id));
        currentSessionId = def.id;
        // Migrate old favorites key if present
        const oldFav = localStorage.getItem('soundboard-favorites');
        if (oldFav) {
            localStorage.setItem(`soundboard-favorites-${def.id}`, oldFav);
            localStorage.removeItem('soundboard-favorites');
        }
    }
    if (!currentSessionId || !sessions.find(s => s.id === currentSessionId)) {
        currentSessionId = sessions[0].id;
        localStorage.setItem('soundboard-currentSessionId', JSON.stringify(currentSessionId));
    }
}
ensureDefaultSession();
function getFavoritesKey() { return `soundboard-favorites-${currentSessionId}`; }
function loadFavorites() {
    try { return JSON.parse(localStorage.getItem(getFavoritesKey()) || '[]'); } catch { return []; }
}
function persistFavorites() {
    localStorage.setItem(getFavoritesKey(), JSON.stringify(favorites));
}
let favorites = loadFavorites();
let expandedCategories = JSON.parse(localStorage.getItem('soundboard-expanded') || '["Tavern & Inn"]'); // First category expanded by default
let activeTab = JSON.parse(localStorage.getItem('soundboard-activeTab') || 'null') || Object.keys(soundLibrary)[0];
const DUCK_FACTOR = 0.3;
let activeBarExpanded = JSON.parse(localStorage.getItem('soundboard-activeBarExpanded') || 'false');
let lightMode = JSON.parse(localStorage.getItem('soundboard-lightMode') || 'false');

// Preset definitions: curated lists of sound ids
const presets = {
    'Horror': {
        icon: 'ğŸ˜±',
        description: 'Eerie ambience, whispers, thunder and unsettling tones.',
        ids: ['heartbeat','whispers','scream','creepy-laugh','clock-ticking','music-box','fog','chains','bat-swarm','ghost','thunder','rain-heavy']
    },
    'Dungeon Crawl': {
        icon: 'ğŸ°',
        description: 'Dark caverns, chains, traps, and lurking creatures.',
        ids: ['dungeon-ambience','water-drip','chains','stone-door','torch','echo-steps','trap-trigger','skeleton','zombie','spider']
    },
    'Tavern Night': {
        icon: 'ğŸº',
        description: 'Warm crowd, lute music, fireplace and ale flowing.',
        ids: ['tavern-crowd','tavern-music','fireplace','pouring-ale','dice-roll','chair-scrape']
    },
    'Stormy Sea': {
        icon: 'ğŸŒŠ',
        description: 'Crashing waves, storms, gulls and creaking ships.',
        ids: ['ocean-waves','storm-at-sea','seagulls','ship-creak','wind-storm','thunder']
    },
    'Sci-Fi Ops': {
        icon: 'ğŸš€',
        description: 'Starship hums, alerts, lasers and teleports.',
        ids: ['spaceship','computer','alarm','laser-shot','robot','teleporter']
    },
    'Night Cage': {
        icon: 'ğŸ•¯ï¸',
        description: 'Claustrophobic darkness, whispers and echoing steps.',
        ids: ['dungeon-ambience','echo-steps','chains','door-creak','whispers','breathing','fog','trap-trigger']
    },
    'Nyctophobia': {
        icon: 'ğŸŒ‘',
        description: 'Stalking in the dark: breath, wind, distant screams.',
        ids: ['breathing','whispers','distant-scream','soft-steps','wind-storm','owl','fog','door-creak','heartbeat']
    },
    'Everdell': {
        icon: 'ğŸŒ³',
        description: 'Cozy woodland life and gentle town bustle.',
        ids: ['forest-ambience','birds','stream','wind-leaves','owl','marketplace','blacksmith','quill-write','page-turn','laughter','music-dance']
    },
    'Gloomhaven': {
        icon: 'ğŸ—¡ï¸',
        description: 'Dungeon crawl with monsters, traps and battle.',
        ids: ['dungeon-ambience','echo-steps','trap-trigger','skeleton','zombie','troll','goblin','spell-impact','sword-clash','war-drum','door-iron']
    },
    'Phantom Ink': {
        icon: 'ğŸ–‹ï¸',
        description: 'Whispers, writing, and eerie quiet.',
        ids: ['quiet-ambience','whispers','ink-scratch','quill-scratch','page-turn-soft','music-box']
    },
    'Ring of Chaos': {
        icon: 'ğŸŒ€',
        description: 'Chaotic magic and unstable energies.',
        ids: ['chaos-surge','dark-magic','lightning','spell-impact','whisper-ritual','war-drum']
    },
    'Stormy Night': {
        icon: 'â›ˆï¸',
        description: 'Rain, thunder and occasional creaks inside.',
        ids: ['rain-heavy','thunder','wind-storm','door-creak','clock-ticking']
    },
    'Ocean Voyage': {
        icon: 'â›µ',
        description: 'Open sea with waves, gulls and rigging.',
        ids: ['ocean-waves','seagulls','ship-creak','rigging','storm-at-sea']
    }
};

// Default Scenes - predefined scenes users can load
const defaultScenes = {
    'Tavern Atmosphere': {
        description: 'Warm tavern with crowd, music, and fireplace.',
        soundIds: ['tavern-crowd', 'tavern-music', 'fireplace', 'pouring-ale'],
        volumes: {},
        delays: {}
    },
    'Horror Ambience': {
        description: 'Eerie atmosphere with whispers and heartbeat.',
        soundIds: ['heartbeat', 'whispers', 'ghost-whispers', 'ambience1'],
        volumes: {},
        delays: {}
    },
    'Battle Scene': {
        description: 'Intense combat with swords, cries, and drums.',
        soundIds: ['sword-clash', 'battle-cry1', 'war-drum', 'shield-block'],
        volumes: {},
        delays: {}
    },
    'Dungeon Exploration': {
        description: 'Dark dungeon with dripping water and echoing steps.',
        soundIds: ['dungeon-ambience', 'water-drip', 'echo-steps', 'torch'],
        volumes: {},
        delays: {}
    },
    'Forest Walk': {
        description: 'Peaceful forest with birds and a babbling stream.',
        soundIds: ['forest-ambience', 'birds', 'stream', 'wind-leaves'],
        volumes: {},
        delays: {}
    },
    'Coastal Town': {
        description: 'Harbour sounds with seagulls and ship creaks.',
        soundIds: ['harbor', 'seagulls', 'ship-creak', 'bell-tower'],
        volumes: {},
        delays: {}
    },
    'Magic Ritual': {
        description: 'Mystical atmosphere with chanting and bells.',
        soundIds: ['chanting', 'gong', 'bells', 'whisper-ritual'],
        volumes: {},
        delays: {}
    },
    'Storm Inside': {
        description: 'Cozy interior during a storm.',
        soundIds: ['rain-heavy', 'thunder', 'fireplace', 'clock-ticking'],
        volumes: {},
        delays: {}
    }
};

function toggleCategory(category) {
    const index = expandedCategories.indexOf(category);
    if (index >= 0) {
        expandedCategories.splice(index, 1);
    } else {
        expandedCategories.push(category);
    }
    localStorage.setItem('soundboard-expanded', JSON.stringify(expandedCategories));
    render();
}

function findSoundById(soundId) {
    for (const [category, sounds] of Object.entries(soundLibrary)) {
        const sound = sounds.find(s => s.id === soundId);
        if (sound) {
            return { sound, category };
        }
    }
    return null;
}

function findSoundByName(soundName) {
    const target = String(soundName || '').toLowerCase();
    for (const [category, sounds] of Object.entries(soundLibrary)) {
        const sound = sounds.find(s => String(s.name).toLowerCase() === target);
        if (sound) return { sound, category };
    }
    return null;
}

function openSearchModal() {
    const modal = document.getElementById('search-modal');
    const input = document.getElementById('search-input');
    const results = document.getElementById('search-results');
    results.innerHTML = '';
    modal.classList.remove('hidden');
    setTimeout(() => input && input.focus(), 0);
}

function closeSearchModal() {
    const modal = document.getElementById('search-modal');
    modal.classList.add('hidden');
    const input = document.getElementById('search-input');
    const results = document.getElementById('search-results');
    const quickSearch = document.getElementById('quick-search-input');
    if (input) input.value = '';
    if (results) results.innerHTML = '';
    if (quickSearch) quickSearch.value = '';
}

function performSearch(query) {
    const q = (query || '').trim().toLowerCase();
    const resultsEl = document.getElementById('search-results');
    if (!q) { resultsEl.innerHTML = ''; return; }
    const matches = [];
    for (const [category, sounds] of Object.entries(soundLibrary)) {
        for (const sound of sounds) {
            const hay = `${sound.name} ${sound.id} ${category}`.toLowerCase();
            if (hay.includes(q)) {
                matches.push({ category, sound });
            }
        }
    }
    const html = matches.map(({ category, sound }) => `
        <button class="w-full text-left px-3 py-2 rounded hover:bg-slate-800/70 border-b border-slate-800 flex items-center gap-3" onclick="goToSound('${sound.id}', '${category}')">
            <span class="text-xl">${sound.icon}</span>
            <div class="flex-1 min-w-0">
                <div class="text-sm font-medium truncate">${sound.name}</div>
                <div class="text-xs text-slate-400 truncate">${category} â€¢ ${getTagsDisplay(sound.name, category)}</div>
            </div>
        </button>
    `).join('');
    const safeQ = sanitizeText(q);
    resultsEl.innerHTML = html || `<div class="px-3 py-2 text-slate-400">No results for "${safeQ}"</div>`;
}

function goToSound(soundId, category) {
    // Ensure category expanded
    if (!expandedCategories.includes(category)) {
        expandedCategories.push(category);
        localStorage.setItem('soundboard-expanded', JSON.stringify(expandedCategories));
    }
    render();
    // After render, scroll and highlight
    setTimeout(() => {
        const el = document.getElementById(`card-${soundId}`);
        if (el) {
            el.scrollIntoView({ behavior: 'smooth', block: 'center' });
            el.classList.add('highlight-pulse-5');
            setTimeout(() => el.classList.remove('highlight-pulse-5'), 5200);
        }
    }, 50);
    // Clear quick search input
    const quickSearch = document.getElementById('quick-search-input');
    if (quickSearch) quickSearch.value = '';
    closeSearchModal();
}

function performQuickSearch(query) {
    if (!query || !query.trim()) return;
    // Open the full search modal with the query pre-filled
    const modal = document.getElementById('search-modal');
    const input = document.getElementById('search-input');
    if (input) input.value = query;
    modal.classList.remove('hidden');
    performSearch(query);
    setTimeout(() => input && input.focus(), 0);
}

function clearQuickSearchIfEmpty() {
    const quickSearch = document.getElementById('quick-search-input');
    const searchModal = document.getElementById('search-modal');
    // Only clear if search modal is closed (user clicked away, not searching)
    if (quickSearch && searchModal && searchModal.classList.contains('hidden')) {
        quickSearch.value = '';
    }
}

function openDiceModal() {
    document.getElementById('dice-modal').classList.remove('hidden');
    const resultEl = document.getElementById('dice-result');
    if (resultEl) resultEl.textContent = '';
    // Hide "Flip Again" button initially (will be shown after coin flip)
    const flipAgainBtn = document.getElementById('coin-flip-again');
    if (flipAgainBtn) flipAgainBtn.classList.add('hidden');
}

function closeDiceModal() {
    const modal = document.getElementById('dice-modal');
    modal.classList.add('hidden');
    const resultEl = document.getElementById('dice-result');
    if (resultEl) resultEl.textContent = '';
    // Hide "Flip Again" button
    const flipAgainBtn = document.getElementById('coin-flip-again');
    if (flipAgainBtn) flipAgainBtn.classList.add('hidden');
    // Reset modal to show dice buttons by default
    const title = modal.querySelector('h3');
    const diceButtons = modal.querySelector('.grid');
    if (title) title.textContent = 'Dice Roll';
    if (diceButtons) diceButtons.style.display = 'grid';
}

function rollDice(sides) {
    const result = Math.floor(Math.random() * sides) + 1;
    const resultEl = document.getElementById('dice-result');
    if (!resultEl) return;
    
    // Hide "Flip Again" button when rolling dice
    const flipAgainBtn = document.getElementById('coin-flip-again');
    if (flipAgainBtn) flipAgainBtn.classList.add('hidden');
    
    // Clear previous content
    resultEl.innerHTML = '';
    
    // Create animated dice element
    const diceDiv = document.createElement('div');
    diceDiv.className = 'dice-face dice-rolling';
    diceDiv.textContent = '?';
    resultEl.appendChild(diceDiv);
    
    // Animate rolling by showing random numbers during the animation
    let rollCount = 0;
    const rollInterval = setInterval(() => {
        rollCount++;
        const temp = Math.floor(Math.random() * sides) + 1;
        diceDiv.textContent = temp.toString();
        
        if (rollCount >= 15) {
            clearInterval(rollInterval);
        }
    }, 60);
    
    // After animation, show the final result
    setTimeout(() => {
        clearInterval(rollInterval);
        diceDiv.classList.remove('dice-rolling');
        diceDiv.textContent = result.toString();
        // Add label below
        const label = document.createElement('div');
        label.className = 'text-sm text-slate-300 mt-2';
        label.textContent = `d${sides}: ${result}`;
        resultEl.appendChild(label);
    }, 1000);
}

function flipCoin() {
    const result = Math.random() < 0.5 ? 'Heads' : 'Tails';
    const resultEl = document.getElementById('dice-result');
    if (!resultEl) return;
    
    // Clear previous content
    resultEl.innerHTML = '';
    
    // Create animated coin element
    const coinDiv = document.createElement('div');
    coinDiv.className = 'coin-face coin-flipping';
    coinDiv.innerHTML = '<div class="text-2xl">ğŸª™</div>';
    resultEl.appendChild(coinDiv);
    
    // Animate flipping by showing alternating visuals during the animation
    let flipCount = 0;
    const flipInterval = setInterval(() => {
        flipCount++;
        // Alternate between edge view and faces during flip
        if (flipCount % 2 === 0) {
            coinDiv.innerHTML = '<div class="text-2xl">ğŸª™</div>';
        } else {
            const temp = Math.random() < 0.5 ? 'H' : 'T';
            coinDiv.innerHTML = `<div class="text-2xl">${temp}</div>`;
        }
        
        if (flipCount >= 8) {
            clearInterval(flipInterval);
        }
    }, 90);
    
    // After animation, show the final result
    setTimeout(() => {
        clearInterval(flipInterval);
        coinDiv.classList.remove('coin-flipping');
        coinDiv.className = `coin-face coin-${result.toLowerCase()}`;
        coinDiv.innerHTML = result === 'Heads' ? '<div class="text-3xl">H</div>' : '<div class="text-3xl">T</div>';
        // Add label below
        const label = document.createElement('div');
        label.className = 'text-lg font-bold text-slate-200 mt-2';
        label.textContent = result;
        resultEl.appendChild(label);
        // Show "Flip Again" button
        const flipAgainBtn = document.getElementById('coin-flip-again');
        if (flipAgainBtn) flipAgainBtn.classList.remove('hidden');
    }, 800);
}

function rollRandomDice() {
    // Open the dice modal to choose dice type
    const modal = document.getElementById('dice-modal');
    const title = modal.querySelector('h3');
    const diceButtons = modal.querySelector('.grid');
    const flipAgainBtn = document.getElementById('coin-flip-again');
    if (title) title.textContent = 'Dice Roll';
    if (diceButtons) diceButtons.style.display = 'grid';
    if (flipAgainBtn) flipAgainBtn.classList.add('hidden');
    openDiceModal();
}

function flipCoinInline() {
    // Open dice modal but show only coin flip
    const modal = document.getElementById('dice-modal');
    const title = modal.querySelector('h3');
    const diceButtons = modal.querySelector('.grid');
    const flipAgainBtn = document.getElementById('coin-flip-again');
    if (title) title.textContent = 'Coin Flip';
    if (diceButtons) diceButtons.style.display = 'none';
    if (flipAgainBtn) flipAgainBtn.classList.add('hidden');
    openDiceModal();
    // Small delay to ensure modal is open, then flip coin
    setTimeout(() => {
        flipCoin();
    }, 100);
}

function applyPreset(presetName) {
    const preset = presets[presetName];
    const ids = preset ? preset.ids : [];
    const newFavorites = [];
    const categoriesToExpand = new Set();
    ids.forEach(id => {
        const found = findSoundById(id);
        if (found) {
            const { sound, category } = found;
            categoriesToExpand.add(category);
            newFavorites.push({
                id: sound.id,
                name: sound.name,
                url: sound.url,
                category: category,
                icon: sound.icon
            });
        }
    });
    favorites = newFavorites;
    persistFavorites();
    // Expand categories included in the preset for quick access
    expandedCategories = Array.from(categoriesToExpand);
    localStorage.setItem('soundboard-expanded', JSON.stringify(expandedCategories));
    render();
}

let presetSearchQuery = '';

function performPresetSearch(query) {
    presetSearchQuery = (query || '').trim().toLowerCase();
    renderPresetsModal();
}

function renderPresetsModal() {
    const grid = document.getElementById('preset-grid');
    if (!grid) return;
    
    let filteredPresets = Object.entries(presets);
    if (presetSearchQuery) {
        filteredPresets = Object.entries(presets).filter(([name, cfg]) => {
            const searchText = `${name} ${cfg.description || ''}`.toLowerCase();
            return searchText.includes(presetSearchQuery);
        });
    }
    
    if (filteredPresets.length === 0 && presetSearchQuery) {
        const safeQ = sanitizeText(presetSearchQuery);
        grid.innerHTML = `<div class="col-span-full text-slate-400 text-center py-8">No presets found matching "${safeQ}"</div>`;
        return;
    }
    
    const cards = filteredPresets.map(([name, cfg]) => `
        <div id="preset-card-${name}" class="bg-slate-800/60 border border-slate-700 rounded-lg p-4 flex flex-col cursor-pointer hover:border-emerald-500/70 transition-colors" onclick="applyPreset('${name}'); closePresetModal()">
            <div class="flex items-center gap-3 mb-2">
                <span class="text-2xl">${cfg.icon || 'ğŸ›ï¸'}</span>
                <div class="font-semibold">${name}</div>
            </div>
            <div class="text-sm text-slate-300 flex-1">${cfg.description || ''}</div>
            <div class="mt-3 text-right text-emerald-300 text-xs">Tap to apply</div>
        </div>
    `).join('');
    grid.innerHTML = cards;
}

function openPresetModal() {
    // Clear search when opening
    presetSearchQuery = '';
    const searchInput = document.getElementById('preset-search-input');
    if (searchInput) searchInput.value = '';
    renderPresetsModal();
    const modal = document.getElementById('preset-modal');
    modal.classList.remove('hidden');
}

function closePresetModal() {
    const modal = document.getElementById('preset-modal');
    modal.classList.add('hidden');
    // Clear search when closing
    presetSearchQuery = '';
    const searchInput = document.getElementById('preset-search-input');
    if (searchInput) searchInput.value = '';
}

function expandAll() {
    expandedCategories = Object.keys(soundLibrary);
    localStorage.setItem('soundboard-expanded', JSON.stringify(expandedCategories));
    render();
}

function collapseAll() {
    expandedCategories = [];
    localStorage.setItem('soundboard-expanded', JSON.stringify(expandedCategories));
    render();
}

function sanitizeText(input) {
    if (typeof input !== 'string') return '';
    return input.replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;'}[c]));
}

function openSessionsModal() {
    renderSessionsModal();
    document.getElementById('sessions-modal').classList.remove('hidden');
}

function closeSessionsModal() {
    document.getElementById('sessions-modal').classList.add('hidden');
    const input = document.getElementById('session-name-input');
    if (input) input.value = '';
}

function renderSessionsModal() {
    const container = document.getElementById('sessions-list');
    if (!container) return;
    const rows = sessions.map(s => `
        <div class="py-2 border-b border-slate-800">
            <div class="mb-2 font-medium ${s.id===currentSessionId?'text-emerald-300':''}">${sanitizeText(s.name)}</div>
            <div class="flex flex-wrap items-center gap-2">
                <button onclick="switchSession('${s.id}')" class="px-3 py-2 text-sm rounded bg-slate-700 hover:bg-slate-600">Switch</button>
                <button onclick="openRenameModal('${s.id}')" class="px-3 py-2 text-sm rounded bg-slate-700 hover:bg-slate-600">Rename</button>
                <button onclick="openConfirmClear('${s.id}')" class="px-3 py-2 text-sm rounded bg-amber-600 hover:bg-amber-700">Clear</button>
                <button onclick="openConfirmDelete('${s.id}')" class="px-3 py-2 text-sm rounded bg-red-600 hover:bg-red-700">Delete</button>
            </div>
        </div>
    `).join('');
    container.innerHTML = rows || '<div class="text-slate-400">No game sessions</div>';
}

let confirmState = { type: null, sessionId: null, groupIndex: null };
function openConfirm(title, message, type, sessionId, groupIndex) {
    confirmState = { type, sessionId, groupIndex };
    const t = document.getElementById('confirm-title');
    const m = document.getElementById('confirm-message');
    if (t) t.textContent = String(title || 'Confirm');
    if (m) m.textContent = String(message || 'Are you sure?');
    document.getElementById('confirm-modal').classList.remove('hidden');
}
function closeConfirmModal() {
    document.getElementById('confirm-modal').classList.add('hidden');
    confirmState = { type: null, sessionId: null, groupIndex: null };
}
function openConfirmClear(id) {
    const s = sessions.find(x => x.id===id);
    openConfirm('Clear Game Session', `Clear all favourites in "${s ? s.name : ''}"?`, 'clear', id, null);
}
function openConfirmDelete(id) {
    const s = sessions.find(x => x.id===id);
    openConfirm('Delete Game Session', `Delete game session "${s ? s.name : ''}"? This cannot be undone.`, 'delete', id, null);
}
function confirmModalProceed() {
    if (confirmState.type === 'clear') {
        clearSession(confirmState.sessionId);
    } else if (confirmState.type === 'delete') {
        deleteSession(confirmState.sessionId);
    } else if (confirmState.type === 'deleteGroup') {
        const group = soundGroups[confirmState.groupIndex];
        if (group) {
            soundGroups.splice(confirmState.groupIndex, 1);
            saveSoundGroups();
            renderGroupsModal();
        }
    } else if (confirmState.type === 'clearAllScenes') {
        soundGroups = [];
        saveSoundGroups();
        renderGroupsModal();
    }
    closeConfirmModal();
}

function openInfoModal() { document.getElementById('info-modal').classList.remove('hidden'); }
function closeInfoModal() { document.getElementById('info-modal').classList.add('hidden'); }

function openImportModal() {
    const m = document.getElementById('import-modal');
    const err = document.getElementById('import-error');
    if (err) { err.classList.add('hidden'); err.textContent=''; }
    const f = document.getElementById('import-file');
    if (f) f.value = '';
    m.classList.remove('hidden');
}
function closeIOModal() {
    document.getElementById('import-modal').classList.add('hidden');
}

function showNotice(message) {
    const el = document.getElementById('notice-message');
    if (el) el.textContent = String(message || '');
    const m = document.getElementById('notice-modal');
    m.classList.remove('hidden');
}
function closeNotice() {
    document.getElementById('notice-modal').classList.add('hidden');
}

// Sound Groups
let soundGroups = JSON.parse(localStorage.getItem('soundboard-groups') || '[]');

function loadSoundGroups() {
    soundGroups = JSON.parse(localStorage.getItem('soundboard-groups') || '[]');
}

function saveSoundGroups() {
    localStorage.setItem('soundboard-groups', JSON.stringify(soundGroups));
}

function openGroupsModal() {
    // Clear search when opening
    sceneSearchQuery = '';
    const searchInput = document.getElementById('groups-search-input');
    if (searchInput) searchInput.value = '';
    renderGroupsModal();
    document.getElementById('groups-modal').classList.remove('hidden');
}

function closeGroupsModal() {
    document.getElementById('groups-modal').classList.add('hidden');
    // Clear search when closing
    sceneSearchQuery = '';
    const searchInput = document.getElementById('groups-search-input');
    if (searchInput) searchInput.value = '';
}

function loadDefaultScenes() {
    let loaded = 0;
    let skipped = 0;
    Object.entries(defaultScenes).forEach(([sceneName, sceneData]) => {
        // Check if scene with this name already exists
        const exists = soundGroups.some(g => g.name.toLowerCase() === sceneName.toLowerCase());
        if (exists) {
            skipped++;
            return;
        }
        // Resolve sound IDs - filter out any that don't exist
        const validSoundIds = [];
        sceneData.soundIds.forEach(soundId => {
            const found = findSoundById(soundId);
            if (found) {
                validSoundIds.push(soundId);
            }
        });
        if (validSoundIds.length > 0) {
            // Resolve volumes to sound IDs (they come as sound names in defaults)
            const resolvedVolumes = {};
            const resolvedDelays = {};
            if (sceneData.volumes) {
                Object.entries(sceneData.volumes).forEach(([soundName, vol]) => {
                    const found = findSoundByName(soundName);
                    if (found) {
                        resolvedVolumes[found.sound.id] = vol;
                    }
                });
            }
            if (sceneData.delays) {
                Object.entries(sceneData.delays).forEach(([soundName, delay]) => {
                    const found = findSoundByName(soundName);
                    if (found) {
                        resolvedDelays[found.sound.id] = delay;
                    }
                });
            }
            soundGroups.push({
                id: 'g_' + Date.now() + Math.random().toString(36).slice(2, 10),
                name: sceneName,
                soundIds: validSoundIds,
                volumes: resolvedVolumes,
                delays: resolvedDelays,
                loop: sceneData.loop || false
            });
            loaded++;
        }
    });
    if (loaded > 0 || skipped > 0) {
        saveSoundGroups();
        renderGroupsModal();
        let msg = '';
        if (loaded > 0) {
            msg = `${loaded} default scene${loaded !== 1 ? 's' : ''} loaded.`;
        }
        if (skipped > 0) {
            msg += (msg ? ' ' : '') + `${skipped} scene${skipped !== 1 ? 's' : ''} skipped (already exist).`;
        }
        showNotice(msg || 'Default scenes loaded.');
    } else {
        showNotice('No default scenes to load.');
    }
}

let sceneSearchQuery = '';

function performSceneSearch(query) {
    sceneSearchQuery = (query || '').trim().toLowerCase();
    renderGroupsModal();
}

function renderGroupsModal() {
    const container = document.getElementById('groups-list');
    if (!container) return;
    
    let filteredGroups = soundGroups;
    if (sceneSearchQuery) {
        filteredGroups = soundGroups.filter(group => {
            const searchText = `${group.name}`.toLowerCase();
            return searchText.includes(sceneSearchQuery);
        });
    }
    
    if (soundGroups.length === 0) {
        container.innerHTML = '<div class="text-slate-400 text-center py-8">No scenes yet. Click "Create Scene" to get started.</div>';
        return;
    }
    
    if (filteredGroups.length === 0 && sceneSearchQuery) {
        const safeQ = sanitizeText(sceneSearchQuery);
        container.innerHTML = `<div class="text-slate-400 text-center py-8">No scenes found matching "${safeQ}"</div>`;
        return;
    }
    
    const html = filteredGroups.map((group, idx) => {
        // Find the original index in soundGroups array
        const originalIdx = soundGroups.findIndex(g => g.id === group.id);
        const soundCount = group.soundIds.length;
        const isLooping = group.loop || false;
        return `
            <div id="scene-card-${group.id}" class="bg-slate-800/60 border border-slate-700 rounded-lg p-4 mb-3 cursor-pointer hover:border-emerald-500/70 transition-colors" onclick="playSoundGroup(${originalIdx})">
                <div class="mb-2">
                    <div class="font-semibold mb-2">${sanitizeText(group.name)}</div>
                    <div class="text-sm text-slate-400 mb-2">${soundCount} sound${soundCount !== 1 ? 's' : ''} â€¢ Tap to play</div>
                    <div class="flex flex-wrap items-center gap-2" onclick="event.stopPropagation()">
                        <button onclick="toggleSceneLoop(${originalIdx})" class="px-3 py-2 text-sm rounded ${isLooping ? 'bg-blue-600 hover:bg-blue-700' : 'bg-slate-700 hover:bg-slate-600'}">
                            ${isLooping ? 'ğŸ” Looping' : 'â†» Loop Off'}
                        </button>
                        <button onclick="openEditGroupModal(${originalIdx})" class="px-3 py-2 text-sm rounded bg-slate-700 hover:bg-slate-600">Edit</button>
                        <button onclick="openRenameGroupModal(${originalIdx})" class="px-3 py-2 text-sm rounded bg-slate-700 hover:bg-slate-600">Rename</button>
                        <button onclick="openConfirmDeleteGroup(${originalIdx})" class="px-3 py-2 text-sm rounded bg-red-600 hover:bg-red-700">Delete</button>
                    </div>
                </div>
            </div>
        `;
    }).join('');
    container.innerHTML = html;
}

let createGroupEditingIndex = null;
function openCreateGroupModal(groupIndex = null) {
    createGroupEditingIndex = groupIndex;
    const container = document.getElementById('group-sounds-list');
    if (!container) return;
    // Render all sounds as checkboxes
    const allSounds = [];
    for (const [category, sounds] of Object.entries(soundLibrary)) {
        sounds.forEach(sound => {
            allSounds.push({ ...sound, category });
        });
    }
    let preSelectedIds = [];
    let existingVolumes = {};
    let existingName = '';
    if (groupIndex !== null && soundGroups[groupIndex]) {
        const group = soundGroups[groupIndex];
        existingName = group.name;
        preSelectedIds = group.soundIds || [];
        existingVolumes = group.volumes || {};
    }
    const html = allSounds.map(sound => {
        const isChecked = preSelectedIds.includes(sound.id);
        return `
        <label id="group-sound-${sound.id}" class="flex items-center gap-2 p-2 bg-slate-800/50 rounded border border-slate-700 cursor-pointer hover:bg-slate-700/50">
            <input type="checkbox" value="${sound.id}" class="group-sound-checkbox rounded" ${isChecked ? 'checked' : ''} onchange="updateGroupVolumesSection()" />
            <span class="text-xl">${sound.icon}</span>
            <span class="text-sm flex-1">${sound.name}</span>
        </label>
    `;
    }).join('');
    container.innerHTML = html;
    const nameInput = document.getElementById('group-name-input');
    const err = document.getElementById('group-name-error');
    if (nameInput) nameInput.value = existingName;
    if (err) { err.classList.add('hidden'); err.textContent = ''; }
    // Clear search when opening modal
    const searchInput = document.getElementById('group-search-input');
    const searchResults = document.getElementById('group-search-results');
    if (searchInput) searchInput.value = '';
    if (searchResults) {
        searchResults.innerHTML = '';
        searchResults.classList.add('hidden');
    }
    updateGroupVolumesSection();
    document.getElementById('create-group-modal').classList.remove('hidden');
    document.querySelector('#create-group-modal h3').textContent = groupIndex !== null ? 'Edit Scene' : 'Create Scene';
}

function closeCreateGroupModal() {
    document.getElementById('create-group-modal').classList.add('hidden');
    createGroupEditingIndex = null;
    // Clear search when closing
    const searchInput = document.getElementById('group-search-input');
    const searchResults = document.getElementById('group-search-results');
    if (searchInput) searchInput.value = '';
    if (searchResults) {
        searchResults.innerHTML = '';
        searchResults.classList.add('hidden');
    }
}

function performGroupSearch(query) {
    const q = (query || '').trim().toLowerCase();
    const resultsEl = document.getElementById('group-search-results');
    if (!resultsEl) return;
    
    if (!q) {
        resultsEl.innerHTML = '';
        resultsEl.classList.add('hidden');
        return;
    }
    
    resultsEl.classList.remove('hidden');
    
    const matches = [];
    for (const [category, sounds] of Object.entries(soundLibrary)) {
        for (const sound of sounds) {
            const hay = `${sound.name} ${sound.id} ${category}`.toLowerCase();
            if (hay.includes(q)) {
                matches.push({ category, sound });
            }
        }
    }
    
    if (matches.length === 0) {
        const safeQ = sanitizeText(q);
        resultsEl.innerHTML = `<div class="px-3 py-2 text-slate-400 text-sm">No results for "${safeQ}"</div>`;
        return;
    }
    
    const html = matches.map(({ category, sound }) => `
        <button class="w-full text-left px-3 py-2 rounded hover:bg-slate-800/70 border-b border-slate-800 flex items-center gap-3" onclick="goToSoundInGroup('${sound.id}')">
            <span class="text-xl">${sound.icon}</span>
            <div class="flex-1 min-w-0">
                <div class="text-sm font-medium truncate">${sound.name}</div>
                <div class="text-xs text-slate-400 truncate">${category}</div>
            </div>
        </button>
    `).join('');
    resultsEl.innerHTML = html;
}

function goToSoundInGroup(soundId) {
    const soundLabel = document.getElementById(`group-sound-${soundId}`);
    const soundsList = document.getElementById('group-sounds-list');
    if (!soundLabel || !soundsList) return;
    
    // Scroll to the sound
    soundLabel.scrollIntoView({ behavior: 'smooth', block: 'center' });
    
    // Highlight it
    soundLabel.classList.add('highlight-pulse-5');
    setTimeout(() => soundLabel.classList.remove('highlight-pulse-5'), 5200);
    
    // Clear search input and hide results
    const searchInput = document.getElementById('group-search-input');
    const searchResults = document.getElementById('group-search-results');
    if (searchInput) searchInput.value = '';
    if (searchResults) {
        searchResults.innerHTML = '';
        searchResults.classList.add('hidden');
    }
}

function updateGroupVolumesSection() {
    const checkboxes = document.querySelectorAll('.group-sound-checkbox:checked');
    const volumesSection = document.getElementById('group-volumes-section');
    const volumesList = document.getElementById('group-volumes-list');
    if (!volumesSection || !volumesList) return;
    
    if (checkboxes.length === 0) {
        volumesSection.classList.add('hidden');
        return;
    }
    
    volumesSection.classList.remove('hidden');
    const allSounds = [];
    for (const [category, sounds] of Object.entries(soundLibrary)) {
        sounds.forEach(sound => {
            allSounds.push({ ...sound, category });
        });
    }
    
    const selectedIds = Array.from(checkboxes).map(cb => cb.value);
    const selectedSounds = allSounds.filter(s => selectedIds.includes(s.id));
    
    let existingVolumes = {};
    if (createGroupEditingIndex !== null && soundGroups[createGroupEditingIndex]) {
        existingVolumes = soundGroups[createGroupEditingIndex].volumes || {};
    }
    
    let existingDelays = {};
    if (createGroupEditingIndex !== null && soundGroups[createGroupEditingIndex]) {
        existingDelays = soundGroups[createGroupEditingIndex].delays || {};
    }
    
    const volumesHtml = selectedSounds.map(sound => {
        const defaultVol = existingVolumes[sound.id] !== undefined ? existingVolumes[sound.id] : getVolumeMemory(sound.id);
        const currentDelay = existingDelays[sound.id] || 0;
        return `
            <div class="p-2 bg-slate-800/50 rounded border border-slate-700">
                <div class="flex items-center gap-2 mb-2">
                    <span class="text-xl w-8">${sound.icon}</span>
                    <span class="text-sm flex-1">${sound.name}</span>
                </div>
                <div class="flex items-center gap-2">
                    <input type="range" min="0" max="1" step="0.01" value="${defaultVol}" 
                        oninput="this.nextElementSibling.textContent = Math.round(this.value * 100) + '%'"
                        data-sound-id="${sound.id}"
                        class="w-32 md:w-56 h-1 rounded-lg appearance-none cursor-pointer group-volume-slider"
                        style="background: linear-gradient(to right, rgb(168, 85, 247) 0%, rgb(168, 85, 247) ${defaultVol * 100}%, rgb(51, 65, 85) ${defaultVol * 100}%, rgb(51, 65, 85) 100%)" />
                    <span class="text-xs text-slate-400 w-10 text-right">${Math.round(defaultVol * 100)}%</span>
                    <button onclick="cycleSoundDelay('${sound.id}')" class="px-2 py-1 text-xs rounded bg-slate-700 hover:bg-slate-600 text-slate-200 delay-btn-${sound.id} min-w-[3.5rem]" data-sound-id="${sound.id}" data-delay="${currentDelay}">
                        ${currentDelay === 0 ? 'None' : currentDelay + 's'}
                    </button>
                </div>
            </div>
        `;
    }).join('');
    volumesList.innerHTML = volumesHtml;
}

function cycleSoundDelay(soundId) {
    const btn = document.querySelector(`.delay-btn-${soundId}`);
    if (!btn) return;
    let currentDelay = parseInt(btn.getAttribute('data-delay') || '0');
    // Cycle: 0 -> 5 -> 10 -> 15 -> 20 -> 25 -> 30 -> 0
    currentDelay += 5;
    if (currentDelay > 30) currentDelay = 0;
    btn.setAttribute('data-delay', currentDelay);
    btn.textContent = currentDelay === 0 ? 'None' : currentDelay + 's';
}

function saveSoundGroup() {
    const nameInput = document.getElementById('group-name-input');
    const err = document.getElementById('group-name-error');
    if (err) { err.classList.add('hidden'); err.textContent = ''; }
    const name = sanitizeText((nameInput?.value || '').trim()).slice(0, 64);
    if (!name) {
        if (err) { err.textContent = 'Please enter a scene name.'; err.classList.remove('hidden'); }
        return;
    }
    // Get selected sounds
    const checkboxes = document.querySelectorAll('.group-sound-checkbox:checked');
    const soundIds = Array.from(checkboxes).map(cb => cb.value);
    if (soundIds.length === 0) {
        if (err) { err.textContent = 'Please select at least one sound.'; err.classList.remove('hidden'); }
        return;
    }
    // Get volumes
    const volumeSliders = document.querySelectorAll('.group-volume-slider');
    const volumes = {};
    volumeSliders.forEach(slider => {
        const soundId = slider.getAttribute('data-sound-id');
        const vol = parseFloat(slider.value);
        volumes[soundId] = vol;
    });
    
    // Get delays
    const delayButtons = document.querySelectorAll('[class*="delay-btn-"]');
    const delays = {};
    delayButtons.forEach(btn => {
        const soundId = btn.getAttribute('data-sound-id');
        const delay = parseInt(btn.getAttribute('data-delay') || '0');
        delays[soundId] = delay;
    });
    
    if (createGroupEditingIndex !== null) {
        // Update existing group
        const group = soundGroups[createGroupEditingIndex];
        if (group) {
            // Check for duplicate names (excluding current group)
            if (soundGroups.some((g, idx) => idx !== createGroupEditingIndex && g.name.toLowerCase() === name.toLowerCase())) {
                if (err) { err.textContent = 'Scene name must be unique.'; err.classList.remove('hidden'); }
                return;
            }
            group.name = name;
            group.soundIds = soundIds;
            group.volumes = volumes;
            group.delays = delays;
            // Preserve loop state
            if (group.loop === undefined) group.loop = false;
        }
    } else {
        // Check for duplicate names
        if (soundGroups.some(g => g.name.toLowerCase() === name.toLowerCase())) {
            if (err) { err.textContent = 'Scene name must be unique.'; err.classList.remove('hidden'); }
            return;
        }
        // Create new group
        soundGroups.push({ id: 'g_' + Date.now(), name, soundIds, volumes, delays, loop: false });
    }
    saveSoundGroups();
    closeCreateGroupModal();
    renderGroupsModal();
    render();
}

function openEditGroupModal(groupIndex) {
    openCreateGroupModal(groupIndex);
}

function toggleSceneLoop(groupIndex) {
    const group = soundGroups[groupIndex];
    if (!group) return;
    group.loop = !group.loop;
    saveSoundGroups();
    renderGroupsModal();
}

// Fade out and stop all active sounds
function fadeOutAllSounds(duration = 2000) {
    const fadeOutSounds = Object.entries(activeSounds).filter(([id, sound]) => sound.isPlaying);
    if (fadeOutSounds.length === 0) return Promise.resolve();
    
    return new Promise((resolve) => {
        const fadeOutPromises = fadeOutSounds.map(([soundId, sound]) => {
            return new Promise((resolveSound) => {
                const audio = audioElements[soundId];
                if (!audio || audio.paused) {
                    resolveSound();
                    return;
                }
                
                const startVolume = audio.volume;
                const startTime = Date.now();
                const fadeInterval = setInterval(() => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);
                    const newVolume = startVolume * (1 - progress);
                    
                    if (audio && !audio.paused) {
                        // Use Web Audio API for iOS compatibility
                        setVolumeViaWebAudio(soundId, newVolume);
                        // Also set HTML5 volume as fallback
                        try {
                            audio.volume = newVolume;
                        } catch(e) {}
                    }
                    
                    if (progress >= 1 || !audio || audio.paused) {
                        clearInterval(fadeInterval);
                        if (audio) {
                            audio.pause();
                            audio.currentTime = 0;
                            audio.volume = startVolume; // Restore volume
                        }
                        if (activeSounds[soundId]) {
                            activeSounds[soundId].isPlaying = false;
                        }
                        resolveSound();
                    }
                }, 16); // ~60fps
            });
        });
        
        Promise.all(fadeOutPromises).then(() => {
            // Clear all active sounds after fade out
            fadeOutSounds.forEach(([soundId]) => {
                if (activeSounds[soundId]) {
                    delete activeSounds[soundId];
                }
            });
            resolve();
        });
    });
}

// Fade in a sound
function fadeInSound(soundId, targetVolume, duration = 2000) {
    const audio = audioElements[soundId];
    if (!audio) return;
    
    // Start at 0 volume using Web Audio API
    setVolumeViaWebAudio(soundId, 0);
    try {
        audio.volume = 0;
    } catch(e) {}
    
    if (audio.paused) {
        audio.play().catch(() => {});
    }
    
    const startTime = Date.now();
    const fadeInterval = setInterval(() => {
        const elapsed = Date.now() - startTime;
        const progress = Math.min(elapsed / duration, 1);
        const newVolume = targetVolume * progress;
        
        if (audio && !audio.paused) {
            // Use Web Audio API for iOS compatibility
            setVolumeViaWebAudio(soundId, newVolume);
            // Also set HTML5 volume as fallback
            try {
                audio.volume = newVolume;
            } catch(e) {}
        }
        
        if (progress >= 1) {
            clearInterval(fadeInterval);
            if (audio) {
                // Final volume set using Web Audio API
                setVolumeViaWebAudio(soundId, targetVolume);
                try {
                    audio.volume = targetVolume;
                } catch(e) {}
            }
        }
    }, 16); // ~60fps
}

function playSoundGroup(groupIndex) {
    const group = soundGroups[groupIndex];
    if (!group) return;
    const volumes = group.volumes || {};
    const delays = group.delays || {};
    const shouldLoop = group.loop || false;
    
    // Clear any previous scene timeouts and intervals
    sceneTimeouts.forEach(timeoutId => {
        clearTimeout(timeoutId);
    });
    sceneTimeouts = [];
    sceneIntervals.forEach(intervalId => {
        clearInterval(intervalId);
    });
    sceneIntervals = [];
    
    // Fade out all currently active sounds first (2000ms fade out)
    fadeOutAllSounds(2000).then(() => {
        // Wait a brief moment after fade out completes before starting new scene
        const bufferTimeout = setTimeout(() => {
            // Play all sounds in the group with their default volumes and delays
            group.soundIds.forEach(soundId => {
                const found = findSoundById(soundId);
                if (found) {
                    const { sound, category } = found;
                    const defaultVol = volumes[soundId] !== undefined ? volumes[soundId] : getVolumeMemory(sound.id);
                    const delay = delays[soundId] || 0;
                    
                    // Set volume memory first so playSound uses it
                    const volumeMem = JSON.parse(localStorage.getItem('soundboard-volumeMemory') || '{}');
                    volumeMem[sound.id] = defaultVol;
                    localStorage.setItem('soundboard-volumeMemory', JSON.stringify(volumeMem));
                    
                    // Play sound function - starts at volume 0 then fades in smoothly
                    const playSoundAndFadeIn = () => {
                        // Set volume to 0 BEFORE playing to ensure smooth fade-in
                        const audio = getAudioElement(sound.id, sound.url, false);
                        getGainNode(sound.id, audio);
                        setVolumeViaWebAudio(sound.id, 0);
                        try {
                            audio.volume = 0;
                        } catch(e) {}
                        
                        // If scene looping is enabled AND sound has no delay, set loop before playing
                        // Sounds with delays should never loop (they're typically one-time events)
                        if (shouldLoop && delay === 0) {
                            setLoopBeforePlay(sound.id, sound.name, sound.url, category, sound.icon);
                            // Actually play it
                            playSound(sound.id, sound.name, sound.url, category, sound.icon);
                        } else {
                            playSound(sound.id, sound.name, sound.url, category, sound.icon);
                        }
                        
                        // Ensure volume is 0 immediately after play
                        // Use requestAnimationFrame to ensure volume stays at 0 until fade-in starts
                        const ensureVolumeZero = () => {
                            const audio = audioElements[sound.id];
                            if (audio) {
                                setVolumeViaWebAudio(sound.id, 0);
                                try {
                                    audio.volume = 0;
                                } catch(e) {}
                            }
                        };
                        
                        // Keep volume at 0 using interval until audio is confirmed playing
                        const volumeZeroInterval = setInterval(() => {
                            const audio = audioElements[sound.id];
                            if (audio && !audio.paused) {
                                ensureVolumeZero();
                            }
                        }, 16); // ~60fps
                        
                        sceneIntervals.push(volumeZeroInterval);
                        
                        // Start fade-in very quickly after play starts
                        const fadeInTimeout = setTimeout(() => {
                            // Clear the interval when fade-in starts
                            const intervalIndex = sceneIntervals.indexOf(volumeZeroInterval);
                            if (intervalIndex > -1) {
                                clearInterval(volumeZeroInterval);
                                sceneIntervals.splice(intervalIndex, 1);
                            }
                            
                            const audio = audioElements[sound.id];
                            if (audio && !audio.paused && activeSounds[sound.id]) {
                                fadeInSound(sound.id, defaultVol, 2000);
                                if (activeSounds[sound.id]) {
                                    activeSounds[sound.id].volume = defaultVol;
                                }
                            } else if (audio) {
                                // If not playing yet, set volume directly using Web Audio API
                                setVolumeViaWebAudio(sound.id, defaultVol);
                                try {
                                    audio.volume = defaultVol;
                                } catch(e) {}
                                if (activeSounds[sound.id]) {
                                    activeSounds[sound.id].volume = defaultVol;
                                }
                            }
                        }, 100); // Brief delay to ensure audio has started
                        
                        sceneTimeouts.push(fadeInTimeout);
                        
                        // Safety timeout to clear interval if fade-in doesn't start
                        const safetyTimeout = setTimeout(() => {
                            const intervalIndex = sceneIntervals.indexOf(volumeZeroInterval);
                            if (intervalIndex > -1) {
                                clearInterval(volumeZeroInterval);
                                sceneIntervals.splice(intervalIndex, 1);
                            }
                        }, 500);
                        sceneTimeouts.push(safetyTimeout);
                    };
                    
                    // For sounds without delay: play immediately (will fade in over 2 seconds)
                    // For sounds with delay: wait for fade in to complete (2000ms) + delay time, then play and fade in
                    if (delay > 0) {
                        // Wait for fade in to complete (2000ms for non-delayed sounds), then apply delay, then play
                        const delayTimeout1 = setTimeout(() => {
                            // After fade in completes, wait for delay time, then play
                            const delayMs = delay * 1000;
                            const delayTimeout2 = setTimeout(playSoundAndFadeIn, delayMs);
                            sceneTimeouts.push(delayTimeout2);
                        }, 2000); // Wait for fade in to complete
                        sceneTimeouts.push(delayTimeout1);
                    } else {
                        // Play immediately (fade in will happen after play)
                        playSoundAndFadeIn();
                    }
                }
            });
        }, 100); // Small buffer after fade out
        
        sceneTimeouts.push(bufferTimeout);
    });
    closeGroupsModal();
    render();
}

function openConfirmDeleteGroup(groupIndex) {
    const group = soundGroups[groupIndex];
    openConfirm('Delete Scene', `Delete scene "${group ? group.name : ''}"?`, 'deleteGroup', null, groupIndex);
}

function openConfirmClearAllScenes() {
    openConfirm('Clear All Scenes', `Delete all ${soundGroups.length} scene${soundGroups.length !== 1 ? 's' : ''}? This cannot be undone.`, 'clearAllScenes', null, null);
}

let renameGroupTargetIndex = null;
function openRenameGroupModal(groupIndex) {
    renameGroupTargetIndex = groupIndex;
    const group = soundGroups[groupIndex];
    const input = document.getElementById('rename-group-input');
    const err = document.getElementById('rename-group-error');
    if (err) { err.textContent = ''; err.classList.add('hidden'); }
    if (input) input.value = group ? group.name : '';
    document.getElementById('rename-group-modal').classList.remove('hidden');
}

function closeRenameGroupModal() {
    document.getElementById('rename-group-modal').classList.add('hidden');
    renameGroupTargetIndex = null;
}

function saveRenameGroup() {
    const group = soundGroups[renameGroupTargetIndex];
    if (!group) { closeRenameGroupModal(); return; }
    const input = document.getElementById('rename-group-input');
    const err = document.getElementById('rename-group-error');
    const sanitized = sanitizeText((input?.value || '').trim()).slice(0, 64);
    if (err) { err.textContent = ''; err.classList.add('hidden'); }
    if (!sanitized) {
        if (err) { err.textContent = 'Please enter a scene name.'; err.classList.remove('hidden'); }
        return;
    }
    // Check for duplicate names
    if (soundGroups.some((g, idx) => idx !== renameGroupTargetIndex && g.name.toLowerCase() === sanitized.toLowerCase())) {
        if (err) { err.textContent = 'Scene name must be unique. Please choose another.'; err.classList.remove('hidden'); }
        return;
    }
    group.name = sanitized;
    saveSoundGroups();
    renderGroupsModal();
    closeRenameGroupModal();
}

function createSessionFromModal() {
    const input = document.getElementById('session-name-input');
    const sanitized = sanitizeText((input?.value||'').trim()).slice(0,64);
    const err = document.getElementById('session-create-error');
    if (err) { err.classList.add('hidden'); err.textContent=''; }
    if (!sanitized) { if (err){err.textContent='Please enter a game session name.'; err.classList.remove('hidden');} return; }
    if (sessions.some(s => s.name.toLowerCase() === sanitized.toLowerCase())) {
        if (err){err.textContent='Game session name must be unique. Please choose another.'; err.classList.remove('hidden');}
        return;
    }
    const id = 's_' + Math.random().toString(36).slice(2,10);
    sessions.push({ id, name: sanitized });
    localStorage.setItem('soundboard-sessions', JSON.stringify(sessions));
    currentSessionId = id;
    localStorage.setItem('soundboard-currentSessionId', JSON.stringify(currentSessionId));
    favorites = [];
    persistFavorites();
    renderSessionsModal();
    // Immediately close modal so user can use the new session
    closeSessionsModal();
    render();
    input.value = '';
}

let renameTargetId = null;
function openRenameModal(id) {
    renameTargetId = id;
    const s = sessions.find(x=>x.id===id);
    const input = document.getElementById('rename-input');
    const err = document.getElementById('rename-error');
    if (err){err.textContent=''; err.classList.add('hidden');}
    if (input) input.value = s ? s.name : '';
    document.getElementById('rename-modal').classList.remove('hidden');
}
function closeRenameModal() {
    document.getElementById('rename-modal').classList.add('hidden');
    renameTargetId = null;
}
function saveRenameSession() {
    const s = sessions.find(x=>x.id===renameTargetId);
    if (!s) { closeRenameModal(); return; }
    const input = document.getElementById('rename-input');
    const err = document.getElementById('rename-error');
    const sanitized = sanitizeText((input?.value||'').trim()).slice(0,64);
    if (err){err.textContent=''; err.classList.add('hidden');}
    if (!sanitized) { if (err){err.textContent='Please enter a game session name.'; err.classList.remove('hidden');} return; }
    if (sessions.some(x => x.id!==s.id && x.name.toLowerCase()===sanitized.toLowerCase())) {
        if (err){err.textContent='Game session name must be unique. Please choose another.'; err.classList.remove('hidden');}
        return;
    }
    s.name = sanitized;
    localStorage.setItem('soundboard-sessions', JSON.stringify(sessions));
    renderSessionsModal();
    closeRenameModal();
    // Re-render to update header label if current session was renamed
    render();
}

function clearSession(id) {
    if (!sessions.find(s=>s.id===id)) return;
    localStorage.setItem(`soundboard-favorites-${id}`, '[]');
    if (id===currentSessionId) { favorites = []; render(); }
    renderSessionsModal();
}

function deleteSession(id) {
    if (sessions.length<=1) { showNotice('Cannot delete the last game session.'); return; }
    sessions = sessions.filter(s=>s.id!==id);
    localStorage.setItem('soundboard-sessions', JSON.stringify(sessions));
    localStorage.removeItem(`soundboard-favorites-${id}`);
    if (currentSessionId===id) {
        currentSessionId = sessions[0].id;
        localStorage.setItem('soundboard-currentSessionId', JSON.stringify(currentSessionId));
        favorites = loadFavorites();
        render();
    }
    renderSessionsModal();
}

function sessionsPopulateSelect() {
    const sel = document.getElementById('session-select');
    if (!sel) return;
    sel.innerHTML = sessions.map(s => `<option value="${s.id}" ${s.id===currentSessionId?'selected':''}>${sanitizeText(s.name)}</option>`).join('');
}

function switchSession(sessionId) {
    if (!sessions.find(s => s.id === sessionId)) return;
    currentSessionId = sessionId;
    localStorage.setItem('soundboard-currentSessionId', JSON.stringify(currentSessionId));
    favorites = loadFavorites();
    render();
    const sm = document.getElementById('sessions-modal');
    if (sm && !sm.classList.contains('hidden')) closeSessionsModal();
}

function newSessionPrompt() {
    const name = prompt('New session name:') || '';
    const sanitized = sanitizeText(name.trim()).slice(0, 64);
    if (!sanitized) return;
    const id = 's_' + Math.random().toString(36).slice(2, 10);
    sessions.push({ id, name: sanitized });
    localStorage.setItem('soundboard-sessions', JSON.stringify(sessions));
    currentSessionId = id;
    localStorage.setItem('soundboard-currentSessionId', JSON.stringify(currentSessionId));
    favorites = [];
    persistFavorites();
    sessionsPopulateSelect();
    render();
}

function renameSessionPrompt() {
    const cur = sessions.find(s => s.id === currentSessionId);
    if (!cur) return;
    const name = prompt('Rename session:', cur.name) || '';
    const sanitized = sanitizeText(name.trim()).slice(0, 64);
    if (!sanitized) return;
    cur.name = sanitized;
    localStorage.setItem('soundboard-sessions', JSON.stringify(sessions));
    sessionsPopulateSelect();
}

function clearSessionConfirm() {
    if (!confirm('Clear all favorites in this session?')) return;
    favorites = [];
    persistFavorites();
    render();
}

function deleteSessionConfirm() {
    if (!confirm('Delete this game session and its data?')) return;
    if (sessions.length <= 1) { alert('Cannot delete the last game session.'); return; }
    localStorage.removeItem(getFavoritesKey());
    sessions = sessions.filter(s => s.id !== currentSessionId);
    localStorage.setItem('soundboard-sessions', JSON.stringify(sessions));
    currentSessionId = sessions[0].id;
    localStorage.setItem('soundboard-currentSessionId', JSON.stringify(currentSessionId));
    favorites = loadFavorites();
    sessionsPopulateSelect();
    render();
}

function exportFavorites() {
    const names = (favorites||[]).map(f => f.name).filter(n => !!n);
    const unique = Array.from(new Set(names));
    
    // Export scenes with sound names, volumes, and delays
    const exportedScenes = (soundGroups || []).map(group => {
        const soundNames = [];
        const volumes = {};
        const delays = {};
        group.soundIds.forEach(soundId => {
            const found = findSoundById(soundId);
            if (found) {
                soundNames.push(found.sound.name);
                if (group.volumes && group.volumes[soundId] !== undefined) {
                    volumes[found.sound.name] = group.volumes[soundId];
                }
                if (group.delays && group.delays[soundId] !== undefined) {
                    delays[found.sound.name] = group.delays[soundId];
                }
            }
        });
        return {
            name: group.name,
            soundNames: soundNames,
            volumes: volumes,
            delays: delays,
            loop: group.loop || false
        };
    });
    
    const data = { 
        version: 3, 
        names: unique,
        scenes: exportedScenes
    };
    const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    const sess = sessions.find(s => s.id === currentSessionId);
    a.download = `soundboard_${(sess?.name||'session').replace(/\s+/g,'_').toLowerCase()}.json`;
    document.body.appendChild(a);
    a.click();
    setTimeout(() => { URL.revokeObjectURL(url); a.remove(); }, 0);
}

function importFavoritesFromInput() {
    const file = document.getElementById('import-file')?.files?.[0];
    const err = document.getElementById('import-error');
    if (err) { err.classList.add('hidden'); err.textContent=''; }
    if (!file) { if (err){err.textContent='Please choose a JSON file.'; err.classList.remove('hidden');} return; }
    const reader = new FileReader();
    reader.onload = () => {
        try {
            const obj = JSON.parse(String(reader.result || '{}'));
            // Support v3 (names + scenes), v2 (names only), and v1 (favorites objects)
            let names = Array.isArray(obj?.names) ? obj.names : Array.isArray(obj?.favorites) ? obj.favorites.map(x => x?.name) : [];
            names = names.map(n => sanitizeText(String(n||'').slice(0,128))).filter(n => !!n);
            const seen = new Set();
            const unique = names.filter(n => { const k=n.toLowerCase(); if (seen.has(k)) return false; seen.add(k); return true; });
            // Map names to sounds in the library
            const resolved = unique.map(n => findSoundByName(n)).filter(Boolean);
            const missing = unique.filter(n => !findSoundByName(n));
            favorites = resolved.map(({ sound, category }) => ({ id: sound.id, name: sound.name, url: sound.url, category, icon: sound.icon }));
            persistFavorites();
            
            // Import scenes if available (v3 format)
            let scenesImported = 0;
            let scenesMissing = 0;
            if (Array.isArray(obj?.scenes)) {
                obj.scenes.forEach(sceneData => {
                    if (!sceneData.name || !Array.isArray(sceneData.soundNames)) return;
                    const sceneName = sanitizeText(String(sceneData.name).slice(0, 64));
                    if (!sceneName) return;
                    
                    const sceneSoundIds = [];
                    const sceneVolumes = {};
                    const sceneDelays = {};
                    sceneData.soundNames.forEach(soundName => {
                        const found = findSoundByName(soundName);
                        if (found) {
                            sceneSoundIds.push(found.sound.id);
                            // Get volume from imported data if available
                            if (sceneData.volumes && sceneData.volumes[soundName] !== undefined) {
                                const vol = parseFloat(sceneData.volumes[soundName]);
                                if (!isNaN(vol) && vol >= 0 && vol <= 1) {
                                    sceneVolumes[found.sound.id] = vol;
                                }
                            }
                            // Get delay from imported data if available
                            if (sceneData.delays && sceneData.delays[soundName] !== undefined) {
                                const delay = parseInt(sceneData.delays[soundName]);
                                if (!isNaN(delay) && delay >= 0 && delay <= 30) {
                                    sceneDelays[found.sound.id] = delay;
                                }
                            }
                        } else {
                            scenesMissing++;
                        }
                    });
                    
                    if (sceneSoundIds.length > 0) {
                        // Check for duplicate scene name
                        const existingIndex = soundGroups.findIndex(g => g.name.toLowerCase() === sceneName.toLowerCase());
                        const importedLoop = sceneData.loop === true;
                        if (existingIndex >= 0) {
                            // Update existing scene
                            soundGroups[existingIndex].soundIds = sceneSoundIds;
                            soundGroups[existingIndex].volumes = sceneVolumes;
                            soundGroups[existingIndex].delays = sceneDelays;
                            soundGroups[existingIndex].loop = importedLoop;
                        } else {
                            // Create new scene
                            soundGroups.push({
                                id: 'g_' + Date.now() + Math.random().toString(36).slice(2, 10),
                                name: sceneName,
                                soundIds: sceneSoundIds,
                                volumes: sceneVolumes,
                                delays: sceneDelays,
                                loop: importedLoop
                            });
                        }
                        scenesImported++;
                    }
                });
                saveSoundGroups();
            }
            
            render();
            closeIOModal();
            let noticeMsg = '';
            if (missing.length) {
                noticeMsg += `Favourites imported with ${missing.length} sound${missing.length !== 1 ? 's' : ''} not found: ${missing.slice(0,5).join(', ')}${missing.length>5 ? 'â€¦' : ''}. `;
            } else {
                noticeMsg += 'Favourites imported. ';
            }
            if (scenesImported > 0) {
                noticeMsg += `${scenesImported} scene${scenesImported !== 1 ? 's' : ''} imported.`;
                if (scenesMissing > 0) {
                    noticeMsg += ` ${scenesMissing} sound${scenesMissing !== 1 ? 's' : ''} in scenes not found.`;
                }
            }
            showNotice(noticeMsg || 'Favourites imported.');
        } catch (e) {
            if (err){err.textContent='Incorrect file format. Export a sample to see the expected JSON.'; err.classList.remove('hidden');}
        }
    };
    reader.onerror = () => { if (err){err.textContent='Failed to read file.'; err.classList.remove('hidden');} };
    reader.readAsText(file);
}

function favoriteCategory(category) {
    const sounds = soundLibrary[category];
    const soundIds = sounds.map(s => s.id);
    const allFavorited = soundIds.every(id => isFavorite(id));
    if (allFavorited) {
        // Unfavorite all in this category
        favorites = favorites.filter(f => f.category !== category);
    } else {
        // Favorite all missing in this category
    sounds.forEach(sound => {
        if (!isFavorite(sound.id)) {
            favorites.push({ 
                id: sound.id, 
                name: sound.name, 
                url: sound.url, 
                category: category, 
                icon: sound.icon 
            });
        }
    });
    }
    persistFavorites();
    render();
}

        // Initialize Audio Element
        function getAudioElement(soundId, url, loop = false) {
            if (!audioElements[soundId]) {
                // Initialize AudioContext first
                getAudioContext();
                
                const audio = new Audio(url);
                audio.loop = loop;
                
                // Set volume on audio element (fallback for non-iOS or if Web Audio fails)
                const savedVolume = getVolumeMemory(soundId);
                audio.volume = savedVolume;
                
                audio.addEventListener('ended', () => {
                    if (!audio.loop) {
                        stopSound(soundId);
                    }
                });
                
                let lastRenderTime = 0;
                audio.addEventListener('timeupdate', () => {
                    if (activeSounds[soundId]) {
                        activeSounds[soundId].currentTime = audio.currentTime;
                        activeSounds[soundId].duration = audio.duration;
                        // Only render once per second to reduce flickering
                        const now = Date.now();
                        if (now - lastRenderTime > 1000) {
                            lastRenderTime = now;
                            render();
                        }
                    }
                });
                
                audio.addEventListener('loadedmetadata', () => {
                    if (activeSounds[soundId]) {
                        activeSounds[soundId].duration = audio.duration;
                        render();
                    }
                });
                
                audio.addEventListener('play', () => {
                    // When audio starts playing, create gain node if it doesn't exist
                    // This ensures Web Audio API connection is established
                    if (audioContext && audioContext.state !== 'closed') {
                        try {
                            getGainNode(soundId, audio);
                            // Resume context if suspended (iOS requirement)
                            if (audioContext.state === 'suspended') {
                                audioContext.resume();
                            }
                        } catch(e) {
                            // Ignore errors - might already be connected
                        }
                    }
                });
                
                audioElements[soundId] = audio;
            }
            return audioElements[soundId];
        }

        // Play/Pause Sound
        function playSound(soundId, soundName, url, category, icon) {
    // Check if sound is already in activeSounds (paused or stopped)
    const sound = activeSounds[soundId];
    const loop = sound ? sound.loop : false;
    const audio = getAudioElement(soundId, url, loop);
    
    if (sound && sound.isPlaying) {
        audio.pause();
        activeSounds[soundId].isPlaying = false;
    } else {
        if (!activeSounds[soundId]) {
            // First time playing this sound - use volume memory
            const savedVolume = getVolumeMemory(soundId);
            activeSounds[soundId] = {
                name: soundName,
                url: url,
                category: category,
                icon: icon,
                isPlaying: true,
                loop: false,
                volume: savedVolume,
                smartMix: false,
                duckApplied: false,
                originalVolume: undefined
            };
            
            // Ensure gain node is created before setting volume (Web Audio API)
            getGainNode(soundId, audio);
            
            // Set volume using Web Audio API (iOS compatible)
            setVolumeViaWebAudio(soundId, savedVolume);
            
            // Also set HTML5 volume as fallback
            audio.volume = savedVolume;
        } else {
            // Resuming a paused sound - ensure volume is set
            const vol = activeSounds[soundId].volume || getVolumeMemory(soundId);
            
            // Ensure gain node exists
            getGainNode(soundId, audio);
            
            // Set volume using Web Audio API
            setVolumeViaWebAudio(soundId, vol);
            
            // Also set HTML5 volume as fallback
            audio.volume = vol;
            
            activeSounds[soundId].isPlaying = true;
        }
        
        // Resume AudioContext if suspended (iOS requirement)
        if (audioContext && audioContext.state === 'suspended') {
            audioContext.resume();
        }
        
        // Play audio
        const playPromise = audio.play();
        if (playPromise !== undefined) {
            playPromise.then(() => {
                // Volume set after play() completes (Web Audio API)
                if (activeSounds[soundId]) {
                    const vol = activeSounds[soundId].volume || getVolumeMemory(soundId);
                    setVolumeViaWebAudio(soundId, vol);
                    try {
                        audio.volume = vol;
                    } catch(e) {}
                }
            }).catch(() => {
                // Play was interrupted, but volume should still be set
                if (activeSounds[soundId]) {
                    const vol = activeSounds[soundId].volume || getVolumeMemory(soundId);
                    setVolumeViaWebAudio(soundId, vol);
                    try {
                        audio.volume = vol;
                    } catch(e) {}
                }
            });
        }
    }
    updateDucking();
    render();
}

function setLoopBeforePlay(soundId, soundName, url, category, icon) {
    if (!activeSounds[soundId]) {
        // Sound hasn't been played yet, add it to activeSounds with loop enabled
        const savedVolume = getVolumeMemory(soundId);
        activeSounds[soundId] = {
            name: soundName,
            url: url,
            category: category,
            icon: icon,
            isPlaying: false,
            loop: true,
            volume: savedVolume
        };
        // Pre-initialize audio with loop
        const audio = getAudioElement(soundId, url, true);
        audio.volume = savedVolume;
    } else {
        // Sound already exists, just toggle loop
        toggleLoop(soundId);
    }
    render();
}

function setSmartMixBeforePlay(soundId, soundName, url, category, icon) {
    if (!activeSounds[soundId]) {
        const savedVolume = getVolumeMemory(soundId);
        activeSounds[soundId] = {
            name: soundName,
            url: url,
            category: category,
            icon: icon,
            isPlaying: false,
            loop: false,
            volume: savedVolume,
            smartMix: true,
            duckApplied: false,
            originalVolume: undefined
        };
        const audio = getAudioElement(soundId, url, false);
        audio.volume = savedVolume;
    } else {
        toggleSmartMix(soundId);
    }
    updateDucking();
    render();
}

        // Stop Sound
        function stopSound(soundId) {
            const audio = audioElements[soundId];
            if (audio) {
                audio.pause();
                audio.currentTime = 0;
            }
            delete activeSounds[soundId];
            updateDucking();
            render();
        }

        // Toggle Loop
        function toggleLoop(soundId) {
            const audio = audioElements[soundId];
            const newLoop = !activeSounds[soundId].loop;
            if (audio) {
                audio.loop = newLoop;
            }
            activeSounds[soundId].loop = newLoop;
            render();
        }

        // Set Volume
        function setVolume(soundId, volume) {
            // Use Web Audio API first (works on iOS)
            const success = setVolumeViaWebAudio(soundId, volume);
            
            // Fallback to HTML5 audio volume
            const audio = audioElements[soundId];
            if (!success && audio) {
                try {
                    audio.volume = volume;
                } catch(e) {}
            }
            
            if (activeSounds[soundId]) {
                activeSounds[soundId].volume = volume;
            }
            
            // Save volume memory (can be async)
            try {
                const volumeMem = JSON.parse(localStorage.getItem('soundboard-volumeMemory') || '{}');
                volumeMem[soundId] = volume;
                localStorage.setItem('soundboard-volumeMemory', JSON.stringify(volumeMem));
            } catch (e) {
                // Ignore storage errors
            }
            //render();
        }
        
        // Get Volume Memory
        function getVolumeMemory(soundId) {
            const volumeMem = JSON.parse(localStorage.getItem('soundboard-volumeMemory') || '{}');
            return volumeMem[soundId] !== undefined ? volumeMem[soundId] : 0.7;
        }
        
        // Reset Volume to Default
        function resetVolume(soundId) {
            const defaultVol = 0.7; // Default volume
            setVolume(soundId, defaultVol);
            render();
        }

        function toggleSmartMix(soundId) {
            if (!activeSounds[soundId]) return;
            activeSounds[soundId].smartMix = !activeSounds[soundId].smartMix;
            updateDucking();
            render();
        }

        function updateDucking() {
            // Find if any priority (smartMix) sound is currently playing
            const priorityIds = Object.entries(activeSounds)
                .filter(([_, s]) => s.isPlaying && s.smartMix)
                .map(([id]) => id);
            const hasPriority = priorityIds.length > 0;
            Object.entries(activeSounds).forEach(([id, s]) => {
                const audio = audioElements[id];
                if (!audio) return;
                if (hasPriority && !s.smartMix && s.isPlaying) {
                    if (!s.duckApplied) {
                        s.originalVolume = s.volume;
                        const newVol = Math.max(0, Math.min(1, s.volume * DUCK_FACTOR));
                        s.volume = newVol;
                        // Use Web Audio API for iOS compatibility
                        setVolumeViaWebAudio(id, newVol);
                        // Also set HTML5 volume as fallback
                        try {
                            audio.volume = newVol;
                        } catch(e) {}
                        s.duckApplied = true;
                    }
                } else if (s.duckApplied) {
                    const restore = s.originalVolume != null ? s.originalVolume : s.volume;
                    s.volume = restore;
                    // Use Web Audio API for iOS compatibility
                    setVolumeViaWebAudio(id, restore);
                    // Also set HTML5 volume as fallback
                    try {
                        audio.volume = restore;
                    } catch(e) {}
                    s.originalVolume = undefined;
                    s.duckApplied = false;
                }
            });
        }

        function clearAllActiveSounds() {
            // Cancel all pending scene timeouts
            sceneTimeouts.forEach(timeoutId => {
                clearTimeout(timeoutId);
            });
            sceneTimeouts = [];
            
            // Cancel all pending scene intervals
            sceneIntervals.forEach(intervalId => {
                clearInterval(intervalId);
            });
            sceneIntervals = [];
            
            // Stop all currently playing sounds
            Object.keys(activeSounds).forEach(soundId => {
                const audio = audioElements[soundId];
                if (audio) {
                    audio.pause();
                    audio.currentTime = 0;
                }
                delete activeSounds[soundId];
            });
            render();
        }

        function toggleActiveBarSize() {
            activeBarExpanded = !activeBarExpanded;
            localStorage.setItem('soundboard-activeBarExpanded', JSON.stringify(activeBarExpanded));
            render();
        }

        // Toggle Favorite
        function toggleFavorite(soundId, soundName, url, category, icon) {
            const index = favorites.findIndex(f => f.id === soundId);
            if (index >= 0) {
                favorites.splice(index, 1);
            } else {
                favorites.push({ id: soundId, name: soundName, url: url, category: category, icon: icon });
            }
    persistFavorites();
            render();
        }

        // Clear All Favorites
        function clearAllFavorites() {
            favorites = [];
            persistFavorites();
            render();
        }

        // Check if Favorite
        function isFavorite(soundId) {
            return favorites.some(f => f.id === soundId);
        }

        function getTags(soundName, category) {
            const tags = [];
            const name = (soundName || '').toLowerCase();
            const cat = (category || '').toLowerCase();
            if (/ambience|ambient|hum|stream|waves|wind|crowd/.test(name) || /forest|dungeon|ocean|city|tavern|ambience/.test(cat)) tags.push('ambient');
            if (/scream|impact|slam|clap|gong|glass|break|trap|door/.test(name)) tags.push('event');
            if (/loop|ambience|hum|rain|waves|wind|music/.test(name)) tags.push('loop');
            if (/whisper|breath|quiet|soft/.test(name)) tags.push('subtle');
            if (/dragon|zombie|ghost|skeleton|troll|goblin|spider/.test(name) || /creatures/.test(cat)) tags.push('creature');
            return tags;
        }

        function getTagsDisplay(soundName, category) {
            return getTags(soundName, category).join(', ');
        }

        // Switch Tab
        function switchTab(category) {
            activeTab = category;
    localStorage.setItem('soundboard-activeTab', JSON.stringify(activeTab));
            render();
        }

	// Format time in MM:SS
function formatTime(seconds) {
    if (!seconds || isNaN(seconds)) return '0:00';
    const mins = Math.floor(seconds / 60);
    const secs = Math.floor(seconds % 60);
    return `${mins}:${secs.toString().padStart(2, '0')}`;
}

function toggleLightMode() {
    lightMode = !lightMode;
    localStorage.setItem('soundboard-lightMode', JSON.stringify(lightMode));
    render();
}

        // Render UI
        function render() {
            
// Render Expandable Categories
const categoriesHtml = Object.keys(soundLibrary).map(category => {
    const isExpanded = expandedCategories.includes(category);
    const sounds = soundLibrary[category];
    const allFavorited = sounds.every(s => isFavorite(s.id));
    
    return `
        <div class="mb-4 bg-slate-800/30 backdrop-blur rounded-lg border border-slate-700 overflow-hidden">
            <div class="flex items-center">
    <button onclick="toggleCategory('${category}')" 
        class="flex-1 px-4 py-4 flex items-center justify-between hover:bg-slate-700/50 transition-colors">
        <div class="flex items-center gap-3">
            <span class="text-2xl">${categoryIcons[category]}</span>
            <span class="font-semibold text-lg">${category}</span>
            <span class="text-sm text-slate-400">(${sounds.length})</span>
        </div>
        <span class="text-2xl transform transition-transform ${isExpanded ? 'rotate-180' : ''}">â–¼</span>
    </button>
    <button onclick="event.stopPropagation(); favoriteCategory('${category}')" 
        class="px-4 py-4 hover:bg-slate-700/50 transition-colors border-l border-slate-700" 
        title="${allFavorited ? 'Unfavourite all in this category' : 'Favourite all in this category'}">
        <span class="text-xl">${allFavorited ? 'â­' : 'â˜†'}</span>
    </button>
</div>
            
            ${isExpanded ? `
                <div class="p-3 grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 gap-3 border-t border-slate-700">
                    ${sounds.map(sound => {
                        const isActive = activeSounds[sound.id];
                        const favorite = isFavorite(sound.id);
                        return `
                            <div id="card-${sound.id}" class="relative rounded-lg p-3 border transition-all cursor-pointer ${
                                    isActive?.isPlaying 
                                        ? 'bg-gradient-to-br from-green-600/30 to-emerald-600/30 border-green-500 shadow-md shadow-green-500/20 hover:border-green-400' 
                                        : 'bg-slate-800/50 border-slate-700 hover:border-purple-500'
                                }" onclick="playSound('${sound.id}', '${sound.name}', '${sound.url}', '${category}', '${sound.icon}')">
                                <button onclick="event.stopPropagation(); toggleFavorite('${sound.id}', '${sound.name}', '${sound.url}', '${category}', '${sound.icon}')" 
                                    class="absolute top-1 right-1 p-1 hover:bg-slate-700 rounded transition-colors z-10">
                                    <span class="block text-sm">${favorite ? 'â­' : 'â˜†'}</span>
                                </button>
                                <div class="flex flex-col items-center mb-2 pt-4">
                                    <span class="text-3xl mb-1">${sound.icon}</span>
                                    <h3 class="font-medium text-center text-xs leading-tight">${sound.name}</h3>
                                    ${isActive?.isPlaying ? '<div class="mt-1 flex gap-1"><span class="w-1.5 h-2 bg-green-400 animate-pulse"></span><span class="w-1.5 h-3 bg-green-300 animate-pulse"></span><span class="w-1.5 h-2 bg-green-400 animate-pulse"></span></div>' : ''}
                                    <div class="mt-1 flex flex-wrap justify-center gap-1">
                                        ${getTags(sound.name, category).map(t => `<span class=\"px-1.5 py-0.5 rounded-full text-[10px] bg-slate-700 text-slate-300\">${t}</span>`).join('')}
                                </div>
                                </div>
                                <button onclick="event.stopPropagation(); ${isActive ? `toggleLoop('${sound.id}')` : `setLoopBeforePlay('${sound.id}', '${sound.name}', '${sound.url}', '${category}', '${sound.icon}')`}" 
                                    class="w-full mt-1 px-2 py-1 rounded text-xs font-medium transition-all flex items-center justify-center gap-1 ${
                                        isActive?.loop 
                                            ? 'bg-blue-600 hover:bg-blue-700' 
                                            : 'bg-slate-700 hover:bg-slate-600'
                                    }">
                                    ${isActive?.loop ? 'ğŸ” Looping' : 'â†» Loop Off'}
                                </button>
                                <button onclick="event.stopPropagation(); ${isActive ? `toggleSmartMix('${sound.id}')` : `setSmartMixBeforePlay('${sound.id}', '${sound.name}', '${sound.url}', '${category}', '${sound.icon}')`}" 
                                    class="w-full mt-1 px-2 py-1 rounded text-xs font-medium transition-all flex items-center justify-center gap-1 ${
                                        isActive?.smartMix 
                                            ? 'bg-pink-600 hover:bg-pink-700' 
                                            : 'bg-slate-700 hover:bg-slate-600'
                                    }">
                                    ${isActive?.smartMix ? 'ğŸšï¸ Priority' : 'ğŸšï¸ Normal'}
                                </button>
                            </div>
                        `;
                    }).join('')}
                </div>
            ` : ''}
        </div>
    `;
}).join('');

document.getElementById('categories-container').innerHTML = categoriesHtml;
            // Update active session label
            const sessLbl = document.getElementById('active-session-label');
            if (sessLbl) {
                const sess = sessions.find(s => s.id === currentSessionId);
                sessLbl.textContent = `Game Session: ${sess ? sess.name : 'Default'}`;
            }
            // Apply light mode
            const bodyEl = document.body;
            if (lightMode) {
                bodyEl.classList.add('light-mode');
            } else {
                bodyEl.classList.remove('light-mode');
            }

            // Render Favorites
                const favHtml = favorites.map(sound => {
                    const isActive = activeSounds[sound.id]?.isPlaying;
                    return `
                        <div class="relative">
                            <button onclick="playSound('${sound.id}', '${sound.name}', '${sound.url}', '${sound.category}', '${sound.icon}')" 
                                 class="w-full px-2 py-2 rounded-md font-medium transition-all flex flex-col items-center gap-1 ${
                                    isActive 
                                         ? 'bg-gradient-to-r from-green-600 to-emerald-600 shadow-md shadow-green-500/30' 
                                        : 'bg-gradient-to-r from-purple-600 to-pink-600 hover:from-purple-500 hover:to-pink-500'
                                }">
                                 <span class="text-xl">${sound.icon}</span>
                                 <span class="text-xs text-center leading-tight">${sound.name}</span>
                            </button>
                            <button onclick="toggleFavorite('${sound.id}', '${sound.name}', '${sound.url}', '${sound.category}', '${sound.icon}')" 
                                 class="absolute -top-1.5 -right-1.5 p-1 bg-slate-700 hover:bg-slate-600 rounded-full transition-colors">
                                 <span class="w-3 h-3 block">${icons.x}</span>
                            </button>
                        </div>
                    `;
                }).join('');
                document.getElementById('favorites-grid').innerHTML = favHtml;

            // Sound Grid removed

            // Render Active Sounds (this should already be there at the end of render function)
const playingEntries = Object.entries(activeSounds);
const activeSoundsCount = playingEntries.length;
const activeBar = document.getElementById('active-sounds-bar');
if (activeSoundsCount > 0) {
    activeBar.classList.remove('hidden');
    document.getElementById('active-count').textContent = activeSoundsCount;
    // Adjust size
    const gridEl = document.getElementById('active-sounds-grid');
    const sizeBtn = document.getElementById('activebar-size-btn');
    if (gridEl) {
        if (activeBarExpanded) {
            gridEl.style.maxHeight = '50vh';
        } else {
            gridEl.style.maxHeight = '12rem';
        }
    }
    if (sizeBtn) {
        sizeBtn.textContent = activeBarExpanded ? 'Collapse' : 'Expand';
    }
    const activeHtml = playingEntries.map(([soundId, sound]) => `
        <div class="bg-slate-800 rounded-lg p-3 flex flex-col items-stretch gap-2">
            <div class="flex items-center gap-3">
            <span class="text-xl flex-shrink-0">${sound.icon}</span>
                    <div class="font-medium text-sm truncate">${sound.name}</div>
                <div class="time-display ml-auto flex-shrink-0">
                        ${formatTime(sound.currentTime || 0)} / ${formatTime(sound.duration || 0)}
                    </div>
                </div>
            <div class="flex items-center gap-2 flex-1 min-w-0">
                    <span class="w-4 h-4 text-purple-400 flex-shrink-0">${icons.volume}</span>
                    <input type="range" min="0" max="1" step="0.01" value="${sound.volume}" 
                        id="volume-slider-${soundId}"
                        class="flex-1 h-1 rounded-lg appearance-none cursor-pointer volume-slider-active"
                        style="background: linear-gradient(to right, rgb(168, 85, 247) 0%, rgb(168, 85, 247) ${sound.volume * 100}%, rgb(51, 65, 85) ${sound.volume * 100}%, rgb(51, 65, 85) 100%)" />
                <span class="text-xs text-slate-400 w-10 flex-shrink-0 text-right">${Math.round(sound.volume * 100)}%</span>
                </div>
            <div class="flex gap-1 items-center flex-nowrap">
                <button onclick="toggleSmartMix('${soundId}')" class="px-2 py-1 text-xs rounded ${sound.smartMix ? 'bg-pink-600 hover:bg-pink-700 text-white' : 'bg-slate-700 hover:bg-slate-600 text-slate-200'}" title="Toggle priority smart mix">${sound.smartMix ? 'Priority' : 'Normal'}</button>
                <button onclick="toggleLoop('${soundId}')" 
                    class="p-1.5 rounded transition-colors ${sound.loop ? 'bg-blue-600 hover:bg-blue-700' : 'bg-slate-700 hover:bg-slate-600'}" 
                    title="${sound.loop ? 'Looping' : 'Play once'}">
                    <span class="w-3.5 h-3.5 block">${sound.loop ? icons.repeat : icons.repeat1}</span>
                </button>
                <button onclick="resetVolume('${soundId}')" 
                    class="p-1.5 bg-slate-700 hover:bg-slate-600 rounded transition-colors" 
                    title="Reset to default volume">
                    <span class="w-3.5 h-3.5 block">${icons.refresh}</span>
                </button>
                <button onclick="playSound('${soundId}', '${sound.name}', '${sound.url}', '${sound.category}', '${sound.icon}')" 
                    class="p-1.5 bg-slate-700 hover:bg-slate-600 rounded transition-colors">
                    <span class="w-3.5 h-3.5 block">${sound.isPlaying ? icons.pause : icons.play}</span>
                </button>
                <button onclick="stopSound('${soundId}')" 
                    class="p-1.5 bg-red-600 hover:bg-red-700 rounded transition-colors">
                    <span class="w-3.5 h-3.5 block">${icons.square}</span>
                </button>
            </div>
        </div>
    `).join('');
    document.getElementById('active-sounds-grid').innerHTML = activeHtml;
    
    // Attach event listeners to volume sliders for iOS compatibility
    playingEntries.forEach(([soundId, sound]) => {
        const slider = document.getElementById(`volume-slider-${soundId}`);
        if (slider) {
            const updateVolume = (vol) => {
                const audio = audioElements[soundId];
                
                // Try Web Audio API first (works on iOS)
                const success = setVolumeViaWebAudio(soundId, vol);
                
                if (!success && audio) {
                    // Fallback to HTML5 audio volume (for non-iOS or if Web Audio not available)
                    try {
                        audio.volume = vol;
                    } catch(e) {}
                }
                
                if (activeSounds[soundId]) {
                    activeSounds[soundId].volume = vol;
                }
            };
            
            const saveVolume = (vol) => {
                try {
                    const mem = JSON.parse(localStorage.getItem('soundboard-volumeMemory') || '{}');
                    mem[soundId] = vol;
                    localStorage.setItem('soundboard-volumeMemory', JSON.stringify(mem));
                } catch(e) {}
            };
            
            const handleInput = (e) => {
                // Skip if we're manually updating the slider during touch
                if (isUpdatingSlider) {
                    e.stopPropagation();
                    return;
                }
                
                const vol = parseFloat(e.target.value);
                
                // Use Web Audio API for iOS compatibility
                updateVolume(vol);
                saveVolume(vol);
                e.stopPropagation();
            };
            
            // Use multiple event types for iOS compatibility
            // Input event is critical for iOS - must be non-passive
            slider.addEventListener('input', handleInput, { passive: false, capture: false });
            slider.addEventListener('change', handleInput, { passive: false });
            
            // iOS-specific touch handlers - direct synchronous volume setting
            let touchStartVol = null;
            let isDragging = false;
            let isUpdatingSlider = false; // Prevent recursive updates
            
            slider.addEventListener('touchstart', (e) => {
                isDragging = true;
                isUpdatingSlider = false;
                const audio = audioElements[soundId];
                if (audio) {
                    touchStartVol = audio.volume;
                    // Establish gesture context - set volume property directly
                    if (!audio.paused) {
                        // Direct synchronous assignment - critical for iOS
                        const currentVol = audio.volume;
                        audio.volume = currentVol;
                    }
                }
                e.stopPropagation();
            }, { passive: false, capture: false });
            
            slider.addEventListener('touchmove', (e) => {
                if (!isDragging || isUpdatingSlider) return;
                e.preventDefault(); // Prevent default slider behavior
                e.stopPropagation();
                
                const audio = audioElements[soundId];
                if (!audio || audio.paused) {
                    return;
                }
                
                // Calculate volume from touch position
                const rect = slider.getBoundingClientRect();
                const touch = e.touches[0] || e.changedTouches[0];
                if (!touch) return;
                
                const x = touch.clientX - rect.left;
                const percentage = Math.max(0, Math.min(1, x / rect.width));
                const vol = percentage;
                
                // Set flag to prevent input event from interfering
                isUpdatingSlider = true;
                
                // Update slider value FIRST so visual position matches
                slider.value = vol;
                
                // Update background gradient
                slider.style.background = `linear-gradient(to right, rgb(168, 85, 247) 0%, rgb(168, 85, 247) ${vol * 100}%, rgb(51, 65, 85) ${vol * 100}%, rgb(51, 65, 85) 100%)`;
                
                // Use Web Audio API for iOS compatibility
                setVolumeViaWebAudio(soundId, vol);
                
                // Also set HTML5 volume as fallback
                try {
                    audio.volume = vol;
                } catch(e) {}
                
                // Update state immediately
                if (activeSounds[soundId]) {
                    activeSounds[soundId].volume = vol;
                }
                
                // Clear flag after a brief moment to allow normal input events
                setTimeout(() => {
                    isUpdatingSlider = false;
                }, 50);
            }, { passive: false, capture: false });
            
            slider.addEventListener('touchend', (e) => {
                if (!isDragging) return;
                
                isDragging = false;
                isUpdatingSlider = false;
                
                // Get final volume from slider value or calculate from touch position
                let vol;
                const touch = e.changedTouches[0];
                if (touch) {
                    // Calculate from final touch position
                    const rect = slider.getBoundingClientRect();
                    const x = touch.clientX - rect.left;
                    const percentage = Math.max(0, Math.min(1, x / rect.width));
                    vol = percentage;
                } else {
                    // Fallback to slider value
                    vol = parseFloat(slider.value);
                }
                
                // Ensure slider value matches
                slider.value = vol;
                slider.style.background = `linear-gradient(to right, rgb(168, 85, 247) 0%, rgb(168, 85, 247) ${vol * 100}%, rgb(51, 65, 85) ${vol * 100}%, rgb(51, 65, 85) 100%)`;
                
                // Final volume set using Web Audio API
                setVolumeViaWebAudio(soundId, vol);
                
                // Also set HTML5 volume as fallback
                const audio = audioElements[soundId];
                if (audio) {
                    try {
                        audio.volume = vol;
                    } catch(e) {}
                }
                
                if (activeSounds[soundId]) {
                    activeSounds[soundId].volume = vol;
                }
                
                // Save to localStorage (async is OK here)
                saveVolume(vol);
                e.stopPropagation();
            }, { passive: false, capture: false });
            
            // Also handle touchcancel
            slider.addEventListener('touchcancel', (e) => {
                isDragging = false;
                isUpdatingSlider = false;
                e.stopPropagation();
            }, { passive: false });
            
            // Update gradient when input event fires (for tap-to-jump behavior)
            slider.addEventListener('input', (e) => {
                if (!isUpdatingSlider) {
                    const vol = parseFloat(e.target.value);
                    slider.style.background = `linear-gradient(to right, rgb(168, 85, 247) 0%, rgb(168, 85, 247) ${vol * 100}%, rgb(51, 65, 85) ${vol * 100}%, rgb(51, 65, 85) 100%)`;
                }
            }, { passive: false });
            
            slider.addEventListener('pointermove', (e) => {
                const vol = parseFloat(e.target.value);
                updateVolume(vol);
                e.stopPropagation();
            }, { passive: false });
            slider.addEventListener('pointerup', (e) => {
                const vol = parseFloat(e.target.value);
                updateVolume(vol);
                saveVolume(vol);
                e.stopPropagation();
            }, { passive: false });
            
            // Update background gradient on change
            const updateGradient = () => {
                const vol = parseFloat(slider.value);
                slider.style.background = `linear-gradient(to right, rgb(168, 85, 247) 0%, rgb(168, 85, 247) ${vol * 100}%, rgb(51, 65, 85) ${vol * 100}%, rgb(51, 65, 85) 100%)`;
                const percentDisplay = slider.nextElementSibling;
                if (percentDisplay) {
                    percentDisplay.textContent = Math.round(vol * 100) + '%';
                }
            };
            
            slider.addEventListener('input', updateGradient);
            slider.addEventListener('change', updateGradient);
        }
    });
} else {
    activeBar.classList.add('hidden');
}
        }

        // Keyboard Shortcuts (PC)
        document.addEventListener('keydown', (e) => {
            // Ignore if typing in an input
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.isContentEditable) {
                return;
            }
            
            // Close modals with Escape
            if (e.key === 'Escape') {
                document.querySelectorAll('[id$="-modal"]').forEach(m => m.classList.add('hidden'));
                return;
            }
            
            // Space: Play/pause all active sounds
            if (e.key === ' ' && e.target.tagName !== 'BUTTON') {
                e.preventDefault();
                const playingSounds = Object.entries(activeSounds).filter(([_, s]) => s.isPlaying);
                if (playingSounds.length > 0) {
                    // Pause all
                    playingSounds.forEach(([id]) => {
                        const s = activeSounds[id];
                        playSound(id, s.name, s.url, s.category, s.icon);
                    });
                } else {
                    // Try to play all active sounds
                    Object.entries(activeSounds).forEach(([id, s]) => {
                        playSound(id, s.name, s.url, s.category, s.icon);
                    });
                }
                return;
            }
            
            // S: Stop all sounds
            if (e.key === 's' || e.key === 'S') {
                e.preventDefault();
                clearAllActiveSounds();
                return;
            }
            
            // /: Open search
            if (e.key === '/') {
                e.preventDefault();
                openSearchModal();
                return;
            }
            
            // Numbers 1-9: Play favorites (first 9)
            const num = parseInt(e.key);
            if (num >= 1 && num <= 9) {
                e.preventDefault();
                if (favorites.length >= num) {
                    const fav = favorites[num - 1];
                    playSound(fav.id, fav.name, fav.url, fav.category, fav.icon);
                }
                return;
            }
        });

        // Initial Render
        render();
    </script>
</body>
</html>
